[
  {
    "description": "",
    "tags": [
      {
        "title": "license",
        "description": "MIT",
        "lineNumber": 0
      },
      {
        "title": "file",
        "description": "Crafter.js , minimalist front-end library",
        "lineNumber": 1
      },
      {
        "title": "author",
        "description": "Saul van der Walt - https://github.com/SaulDoesCode/",
        "lineNumber": 2
      }
    ],
    "loc": {
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 4,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 5,
          "column": 0
        },
        "end": {
          "line": 5,
          "column": 13
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "file": "Crafter.js , minimalist front-end library",
    "kind": "file",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      null
    ]
  },
  {
    "description": "Craft - Crafter.js Core Object containing most methods",
    "tags": [],
    "loc": {
      "start": {
        "line": 399,
        "column": 2
      },
      "end": {
        "line": 401,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 402,
          "column": 2
        },
        "end": {
          "line": 806,
          "column": 4
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "Craft",
    "kind": "function",
    "params": [
      {
        "title": "param",
        "name": "arr",
        "lineNumber": 403
      }
    ],
    "members": {
      "instance": [],
      "static": [
        {
          "description": "creates a new bound variable , part of Crafter.js's Data Binding System",
          "tags": [],
          "loc": {
            "start": {
              "line": 792,
              "column": 4
            },
            "end": {
              "line": 792,
              "column": 82
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 793,
                "column": 4
              },
              "end": {
                "line": 798,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "newBind",
          "kind": "function",
          "params": [
            {
              "title": "param",
              "name": "key",
              "lineNumber": 793
            },
            {
              "title": "param",
              "name": "val",
              "lineNumber": 793
            },
            {
              "title": "param",
              "name": "handle",
              "lineNumber": 793
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "newBind"
          ]
        },
        {
          "description": "method for creating custom elements\nconfiguring their lifecycle's and inheritance",
          "tags": [],
          "loc": {
            "start": {
              "line": 770,
              "column": 4
            },
            "end": {
              "line": 773,
              "column": 7
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 774,
                "column": 4
              },
              "end": {
                "line": 791,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "newComponent",
          "kind": "function",
          "params": [
            {
              "title": "param",
              "name": "tag",
              "lineNumber": 774
            },
            {
              "title": "param",
              "name": "config",
              "lineNumber": 774
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "newComponent"
          ]
        },
        {
          "description": "method for generating random alphanumeric strings",
          "tags": [],
          "loc": {
            "start": {
              "line": 757,
              "column": 4
            },
            "end": {
              "line": 757,
              "column": 59
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 758,
                "column": 4
              },
              "end": {
                "line": 758,
                "column": 91
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "randomString",
          "kind": "function",
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "randomString"
          ]
        },
        {
          "description": "sets the value of a bound variable",
          "tags": [],
          "loc": {
            "start": {
              "line": 799,
              "column": 4
            },
            "end": {
              "line": 799,
              "column": 45
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 800,
                "column": 4
              },
              "end": {
                "line": 805,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "setBind",
          "kind": "function",
          "params": [
            {
              "title": "param",
              "name": "key",
              "lineNumber": 800
            },
            {
              "title": "param",
              "name": "val",
              "lineNumber": 800
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "setBind"
          ]
        },
        {
          "description": "Usefull method for validating passwords",
          "tags": [],
          "loc": {
            "start": {
              "line": 741,
              "column": 4
            },
            "end": {
              "line": 743,
              "column": 7
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 744,
                "column": 4
              },
              "end": {
                "line": 756,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "strongPassword",
          "kind": "function",
          "params": [
            {
              "title": "param",
              "name": "pass",
              "lineNumber": 744
            },
            {
              "title": "param",
              "name": "length",
              "lineNumber": 744
            },
            {
              "title": "param",
              "name": "caps",
              "lineNumber": 744
            },
            {
              "title": "param",
              "name": "number",
              "lineNumber": 744
            },
            {
              "title": "param",
              "name": "includeChars",
              "type": {
                "type": "RestType"
              }
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "strongPassword"
          ]
        },
        {
          "description": "function that returns a promise when the DOM and WebComponents are finished loading",
          "tags": [
            {
              "title": "namespace",
              "description": null,
              "lineNumber": 2,
              "type": null,
              "name": "Craft"
            }
          ],
          "loc": {
            "start": {
              "line": 701,
              "column": 4
            },
            "end": {
              "line": 704,
              "column": 7
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 705,
                "column": 4
              },
              "end": {
                "line": 721,
                "column": 6
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "namespace": {
            "name": "Craft"
          },
          "name": "WhenReady",
          "kind": "namespace",
          "params": [
            {
              "title": "param",
              "name": "Scope",
              "lineNumber": 705
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "WhenReady"
          ]
        }
      ]
    },
    "path": [
      "Craft"
    ]
  },
  {
    "description": "Handles WebSockets in a contained manner with send and recieve methods",
    "tags": [],
    "loc": {
      "start": {
        "line": 126,
        "column": 2
      },
      "end": {
        "line": 126,
        "column": 79
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 127,
          "column": 2
        },
        "end": {
          "line": 147,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "CraftSocket",
    "kind": "class",
    "params": [
      {
        "title": "param",
        "name": "wsAddress",
        "lineNumber": 128
      },
      {
        "title": "param",
        "name": "protocols",
        "lineNumber": 128
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "CraftSocket"
    ]
  },
  {
    "description": "Object containing many useful methods for interacting with and manipulating the DOM or creating elements",
    "tags": [],
    "loc": {
      "start": {
        "line": 284,
        "column": 2
      },
      "end": {
        "line": 284,
        "column": 113
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 285,
          "column": 2
        },
        "end": {
          "line": 397,
          "column": 4
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "dom",
    "kind": "function",
    "params": [
      {
        "title": "param",
        "name": "element",
        "lineNumber": 285
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "dom"
    ]
  },
  {
    "description": "Event handeling class",
    "tags": [],
    "loc": {
      "start": {
        "line": 177,
        "column": 2
      },
      "end": {
        "line": 177,
        "column": 30
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 178,
          "column": 2
        },
        "end": {
          "line": 201,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "EventHandler",
    "kind": "class",
    "params": [
      {
        "title": "param",
        "name": "EventType",
        "lineNumber": 179
      },
      {
        "title": "param",
        "name": "Target",
        "lineNumber": 179
      },
      {
        "title": "param",
        "name": "Func",
        "lineNumber": 179
      },
      {
        "title": "param",
        "name": "args",
        "type": {
          "type": "RestType"
        }
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "EventHandler"
    ]
  },
  {
    "description": "forEach is an easy way to loop through Collections and Objects",
    "tags": [],
    "loc": {
      "start": {
        "line": 203,
        "column": 2
      },
      "end": {
        "line": 203,
        "column": 71
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 204,
          "column": 2
        },
        "end": {
          "line": 213,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "forEach",
    "kind": "function",
    "params": [
      {
        "title": "param",
        "name": "iterable",
        "lineNumber": 204
      },
      {
        "title": "param",
        "name": "func",
        "lineNumber": 204
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "forEach"
    ]
  },
  {
    "description": "",
    "tags": [
      {
        "title": "class",
        "description": null,
        "lineNumber": 2,
        "type": null,
        "name": "FunctionIterator"
      }
    ],
    "loc": {
      "start": {
        "line": 85,
        "column": 2
      },
      "end": {
        "line": 88,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 89,
          "column": 2
        },
        "end": {
          "line": 125,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "class": {
      "name": "FunctionIterator"
    },
    "name": "FunctionIterator",
    "kind": "class",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "FunctionIterator"
    ]
  },
  {
    "description": "is - Type Testing / Assertion",
    "tags": [
      {
        "title": "namespace",
        "description": null,
        "lineNumber": 2,
        "type": null,
        "name": "is"
      }
    ],
    "loc": {
      "start": {
        "line": 36,
        "column": 2
      },
      "end": {
        "line": 39,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 40,
          "column": 2
        },
        "end": {
          "line": 76,
          "column": 4
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "namespace": {
      "name": "is"
    },
    "name": "is",
    "kind": "namespace",
    "params": [
      {
        "title": "param",
        "name": "val",
        "lineNumber": 41
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "is"
    ]
  },
  {
    "description": "easy way to get an element either in the document or in another element using CSS selectors",
    "tags": [],
    "loc": {
      "start": {
        "line": 215,
        "column": 2
      },
      "end": {
        "line": 215,
        "column": 100
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 216,
          "column": 2
        },
        "end": {
          "line": 220,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "query",
    "kind": "function",
    "params": [
      {
        "title": "param",
        "name": "selector",
        "lineNumber": 216
      },
      {
        "title": "param",
        "name": "element",
        "lineNumber": 216
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "query"
    ]
  },
  {
    "description": "easy way to query all elements either in the document or in another element using CSS selectors",
    "tags": [],
    "loc": {
      "start": {
        "line": 221,
        "column": 2
      },
      "end": {
        "line": 221,
        "column": 104
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 222,
          "column": 2
        },
        "end": {
          "line": 226,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "queryAll",
    "kind": "function",
    "params": [
      {
        "title": "param",
        "name": "selector",
        "lineNumber": 222
      },
      {
        "title": "param",
        "name": "element",
        "lineNumber": 222
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "queryAll"
    ]
  },
  {
    "description": "similar to forEach in that you can loop through all the elements found with a CSS selector",
    "tags": [],
    "loc": {
      "start": {
        "line": 227,
        "column": 2
      },
      "end": {
        "line": 227,
        "column": 99
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 228,
          "column": 2
        },
        "end": {
          "line": 238,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "queryEach",
    "kind": "function",
    "params": [
      {
        "title": "param",
        "name": "selector",
        "lineNumber": 228
      },
      {
        "title": "param",
        "name": "element",
        "lineNumber": 228
      },
      {
        "title": "param",
        "name": "func",
        "lineNumber": 228
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "queryEach"
    ]
  },
  {
    "description": "Converts any Query/QueryAll to an Array of Nodes even if there is only one Node",
    "tags": [],
    "loc": {
      "start": {
        "line": 78,
        "column": 2
      },
      "end": {
        "line": 78,
        "column": 88
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 79,
          "column": 2
        },
        "end": {
          "line": 83,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "QueryOrNodetoNodeArray",
    "kind": "class",
    "params": [
      {
        "title": "param",
        "name": "val",
        "lineNumber": 79
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "QueryOrNodetoNodeArray"
    ]
  },
  {
    "description": "Variable that is used for Data Binding and other reactive processes",
    "tags": [],
    "loc": {
      "start": {
        "line": 149,
        "column": 2
      },
      "end": {
        "line": 149,
        "column": 76
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 150,
          "column": 2
        },
        "end": {
          "line": 175,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /**\n   * is - Type Testing / Assertion\n   * @namespace is\n   */\n  var is = {\n    Bool: val => typeof val === 'boolean',\n    Arr: val => Array.isArray(val),\n    Arraylike: val => is.Def(val.length) ? true : false,\n    String: val => isT(val, 'string'),\n    Num: val => isT(val, 'number'),\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    Null: (...args) => args.length && args.every(o => o === null),\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    Blob: obj => type(obj, '[object Blob]'),\n    RegExp: obj => type(obj, '[object RegExp]'),\n    Date: obj => type(obj, '[object Date]'),\n    Set: obj => type(obj, '[object Set]'),\n    Symbol: obj => type(obj, '[object Symbol]'),\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    Between: (val, max, min) => (val <= max && val >= min),\n    eq: (a, b) => a === b,\n    lt: (val, other) => val < other,\n    lte: (val, other) => val <= other,\n    bt: (val, other) => val > other,\n    bte: (val, other) => val >= other,\n    ReactiveVariable: (...args) => args.every(o => o instanceof ReactiveVariable ? true : false),\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /** Converts any Query/QueryAll to an Array of Nodes even if there is only one Node */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   *\n   * @class FunctionIterator\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    runOne(funcName, arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, arg, arguments) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /** Variable that is used for Data Binding and other reactive processes */\n  class ReactiveVariable {\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    get() {\n      return this.val\n    }\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n    isReactiveVar() {\n      return true\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /** forEach is an easy way to loop through Collections and Objects */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /** easy way to get an element either in the document or in another element using CSS selectors */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /** easy way to query all elements either in the document or in another element using CSS selectors */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /** similar to forEach in that you can loop through all the elements found with a CSS selector */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.Node(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  function On(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.On();\n    return handle;\n  }\n\n  function Once(eventType, SelectorNode, func) {\n    if (is.Func(SelectorNode)) {\n      func = SelectorNode;\n      SelectorNode = root;\n    }\n    let handle = new EventHandler(eventType, SelectorNode, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /** Object containing many useful methods for interacting with and manipulating the DOM or creating elements */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "ReactiveVariable",
    "kind": "class",
    "params": [
      {
        "title": "param",
        "name": "val",
        "lineNumber": 151
      },
      {
        "title": "param",
        "name": "handle",
        "lineNumber": 151
      }
    ],
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "ReactiveVariable"
    ]
  }
]