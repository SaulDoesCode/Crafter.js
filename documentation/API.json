[
  {
    "description": "",
    "tags": [
      {
        "title": "license",
        "description": "MIT",
        "lineNumber": 0
      },
      {
        "title": "file",
        "description": "Crafter.js , minimalist front-end library",
        "lineNumber": 1
      },
      {
        "title": "author",
        "description": "Saul van der Walt - https://github.com/SaulDoesCode/",
        "lineNumber": 2
      }
    ],
    "loc": {
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 4,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 5,
          "column": 0
        },
        "end": {
          "line": 5,
          "column": 13
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "file": "Crafter.js , minimalist front-end library",
    "kind": "file",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      null
    ]
  },
  {
    "description": "associative collection of functions\nthat can be added,removed or iterated through",
    "tags": [],
    "loc": {
      "start": {
        "line": 221,
        "column": 2
      },
      "end": {
        "line": 224,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 225,
          "column": 2
        },
        "end": {
          "line": 288,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "FunctionIterator",
    "kind": "class",
    "members": {
      "instance": [
        {
          "description": "Add a function to the collection",
          "tags": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            },
            {
              "title": "param",
              "description": "function to be stored in the FunctionIterator Collection",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              },
              "name": "func"
            }
          ],
          "loc": {
            "start": {
              "line": 238,
              "column": 4
            },
            "end": {
              "line": 242,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 243,
                "column": 4
              },
              "end": {
                "line": 250,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            },
            {
              "title": "param",
              "description": "function to be stored in the FunctionIterator Collection",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              },
              "name": "func"
            }
          ],
          "name": "add",
          "kind": "function",
          "memberof": "FunctionIterator",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "FunctionIterator",
            "add"
          ]
        },
        {
          "description": "Check if the FunctionIterator Collection contains a certain function",
          "tags": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            }
          ],
          "loc": {
            "start": {
              "line": 230,
              "column": 4
            },
            "end": {
              "line": 233,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 234,
                "column": 4
              },
              "end": {
                "line": 237,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            }
          ],
          "name": "has",
          "kind": "function",
          "memberof": "FunctionIterator",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "FunctionIterator",
            "has"
          ]
        },
        {
          "description": "Remove a function from the collection",
          "tags": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            }
          ],
          "loc": {
            "start": {
              "line": 251,
              "column": 4
            },
            "end": {
              "line": 254,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 255,
                "column": 4
              },
              "end": {
                "line": 261,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            }
          ],
          "name": "remove",
          "kind": "function",
          "memberof": "FunctionIterator",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "FunctionIterator",
            "remove"
          ]
        },
        {
          "description": "Remove all functions from the collection",
          "tags": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            }
          ],
          "loc": {
            "start": {
              "line": 262,
              "column": 4
            },
            "end": {
              "line": 265,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 266,
                "column": 4
              },
              "end": {
                "line": 271,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            }
          ],
          "name": "removeAll",
          "kind": "function",
          "memberof": "FunctionIterator",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "FunctionIterator",
            "removeAll"
          ]
        },
        {
          "description": "Execute each function in the Collection\nall arguments passed will be applied to each function in the collection\nusefull for centralizing an Event Listener such as a Window Resize event",
          "tags": [],
          "loc": {
            "start": {
              "line": 272,
              "column": 4
            },
            "end": {
              "line": 276,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 277,
                "column": 4
              },
              "end": {
                "line": 279,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "runEach",
          "kind": "function",
          "memberof": "FunctionIterator",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "FunctionIterator",
            "runEach"
          ]
        },
        {
          "description": "Execute a single function in the collection",
          "tags": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            }
          ],
          "loc": {
            "start": {
              "line": 280,
              "column": 4
            },
            "end": {
              "line": 284,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 285,
                "column": 4
              },
              "end": {
                "line": 287,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "name to identify the function with",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "funcName"
            },
            {
              "title": "param",
              "name": "arg",
              "type": {
                "type": "RestType"
              }
            }
          ],
          "name": "runOne",
          "kind": "function",
          "memberof": "FunctionIterator",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "FunctionIterator",
            "runOne"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "FunctionIterator"
    ]
  },
  {
    "description": "is - Type Testing / Assertion",
    "tags": [],
    "loc": {
      "start": {
        "line": 36,
        "column": 2
      },
      "end": {
        "line": 36,
        "column": 38
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 37,
          "column": 2
        },
        "end": {
          "line": 209,
          "column": 4
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "is",
    "kind": "function",
    "params": [
      {
        "title": "param",
        "name": "val",
        "lineNumber": 42
      }
    ],
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Determine if a String contains only characters and numbers (alphanumeric)",
          "tags": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "str"
            }
          ],
          "loc": {
            "start": {
              "line": 148,
              "column": 4
            },
            "end": {
              "line": 151,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 152,
                "column": 4
              },
              "end": {
                "line": 152,
                "column": 51
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "str"
            }
          ],
          "name": "Alphanumeric",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Alphanumeric"
          ]
        },
        {
          "description": "Test if something is an Array",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 53,
              "column": 4
            },
            "end": {
              "line": 56,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 57,
                "column": 4
              },
              "end": {
                "line": 57,
                "column": 70
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Arr",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Arr"
          ]
        },
        {
          "description": "Test if something is an Array-Like",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 58,
              "column": 4
            },
            "end": {
              "line": 61,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 62,
                "column": 4
              },
              "end": {
                "line": 62,
                "column": 91
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Arraylike",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Arraylike"
          ]
        },
        {
          "description": "Determines whether a Number is between a maximum and a minimum",
          "tags": [
            {
              "title": "param",
              "description": "number value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "maximum to compare the value with",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "max"
            },
            {
              "title": "param",
              "description": "minimum to compare the value with",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "min"
            },
            {
              "title": "returns",
              "description": "wether or not the value is between the max and min",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              }
            }
          ],
          "loc": {
            "start": {
              "line": 158,
              "column": 4
            },
            "end": {
              "line": 164,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 165,
                "column": 4
              },
              "end": {
                "line": 165,
                "column": 58
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "number value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "maximum to compare the value with",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "max"
            },
            {
              "title": "param",
              "description": "minimum to compare the value with",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "min"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "wether or not the value is between the max and min",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              }
            }
          ],
          "name": "Between",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Between"
          ]
        },
        {
          "description": "Determine if a variable is of Blob type",
          "tags": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "loc": {
            "start": {
              "line": 118,
              "column": 4
            },
            "end": {
              "line": 121,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 122,
                "column": 4
              },
              "end": {
                "line": 122,
                "column": 43
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "name": "Blob",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Blob"
          ]
        },
        {
          "description": "Test if something is a boolean type",
          "tags": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": null,
              "name": "val"
            }
          ],
          "loc": {
            "start": {
              "line": 38,
              "column": 4
            },
            "end": {
              "line": 41,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 42,
                "column": 4
              },
              "end": {
                "line": 42,
                "column": 41
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": null,
              "name": "val"
            }
          ],
          "name": "Bool",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Bool"
          ]
        },
        {
          "description": "Determines if a number is BIGGER than another",
          "tags": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "num to test with value",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "other"
            }
          ],
          "loc": {
            "start": {
              "line": 184,
              "column": 4
            },
            "end": {
              "line": 188,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 189,
                "column": 4
              },
              "end": {
                "line": 189,
                "column": 35
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "num to test with value",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "other"
            }
          ],
          "name": "bt",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "bt"
          ]
        },
        {
          "description": "Determines if a number is BIGGER than or equal to another",
          "tags": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "num to test with value",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "other"
            }
          ],
          "loc": {
            "start": {
              "line": 190,
              "column": 4
            },
            "end": {
              "line": 194,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 195,
                "column": 4
              },
              "end": {
                "line": 195,
                "column": 37
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "num to test with value",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "other"
            }
          ],
          "name": "bte",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "bte"
          ]
        },
        {
          "description": "Determine if a variable is a Date type",
          "tags": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "loc": {
            "start": {
              "line": 128,
              "column": 4
            },
            "end": {
              "line": 131,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 132,
                "column": 4
              },
              "end": {
                "line": 132,
                "column": 43
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "name": "Date",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Date"
          ]
        },
        {
          "description": "Determine whether a variable is in fact defined",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 68,
              "column": 4
            },
            "end": {
              "line": 71,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 72,
                "column": 4
              },
              "end": {
                "line": 72,
                "column": 72
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Def",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Def"
          ]
        },
        {
          "description": "Determine if a variable is a HTMLElement",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 93,
              "column": 4
            },
            "end": {
              "line": 96,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 97,
                "column": 4
              },
              "end": {
                "line": 97,
                "column": 89
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Element",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Element"
          ]
        },
        {
          "description": "Determines whether a String is a valid Email",
          "tags": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "email"
            }
          ],
          "loc": {
            "start": {
              "line": 153,
              "column": 4
            },
            "end": {
              "line": 156,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 157,
                "column": 4
              },
              "end": {
                "line": 157,
                "column": 185
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "email"
            }
          ],
          "name": "Email",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Email"
          ]
        },
        {
          "description": "Determines if two variables are equal",
          "tags": [
            {
              "title": "param",
              "description": "first value to compare",
              "lineNumber": 2,
              "type": null,
              "name": "a"
            },
            {
              "title": "param",
              "description": "second value to compare",
              "lineNumber": 3,
              "type": null,
              "name": "b"
            }
          ],
          "loc": {
            "start": {
              "line": 166,
              "column": 4
            },
            "end": {
              "line": 170,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 171,
                "column": 4
              },
              "end": {
                "line": 171,
                "column": 25
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "first value to compare",
              "lineNumber": 2,
              "type": null,
              "name": "a"
            },
            {
              "title": "param",
              "description": "second value to compare",
              "lineNumber": 3,
              "type": null,
              "name": "b"
            }
          ],
          "name": "eq",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "eq"
          ]
        },
        {
          "description": "Determine if a variable is a File Object",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 98,
              "column": 4
            },
            "end": {
              "line": 101,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 102,
                "column": 4
              },
              "end": {
                "line": 102,
                "column": 79
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "File",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "File"
          ]
        },
        {
          "description": "Determine if a variable is of a FormData type",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 103,
              "column": 4
            },
            "end": {
              "line": 106,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 107,
                "column": 4
              },
              "end": {
                "line": 107,
                "column": 87
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "FormData",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "FormData"
          ]
        },
        {
          "description": "Determine if a variable is a function",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 113,
              "column": 4
            },
            "end": {
              "line": 116,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 117,
                "column": 4
              },
              "end": {
                "line": 117,
                "column": 78
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Func",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Func"
          ]
        },
        {
          "description": "Determines if a number is LOWER than another",
          "tags": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "num to test with value",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "other"
            }
          ],
          "loc": {
            "start": {
              "line": 172,
              "column": 4
            },
            "end": {
              "line": 176,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 177,
                "column": 4
              },
              "end": {
                "line": 177,
                "column": 35
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "num to test with value",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "other"
            }
          ],
          "name": "lt",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "lt"
          ]
        },
        {
          "description": "Determines if a number is LOWER than or equal to another",
          "tags": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "num to test with value",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "other"
            }
          ],
          "loc": {
            "start": {
              "line": 178,
              "column": 4
            },
            "end": {
              "line": 182,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 183,
                "column": 4
              },
              "end": {
                "line": 183,
                "column": 37
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "num to test with value",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "other"
            }
          ],
          "name": "lte",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "lte"
          ]
        },
        {
          "description": "Determine if a variable is a Map",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 108,
              "column": 4
            },
            "end": {
              "line": 111,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 112,
                "column": 4
              },
              "end": {
                "line": 112,
                "column": 77
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Map",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Map"
          ]
        },
        {
          "description": "Test if something is a Native JavaScript feature",
          "tags": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": null,
              "name": "val"
            }
          ],
          "loc": {
            "start": {
              "line": 201,
              "column": 4
            },
            "end": {
              "line": 204,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 205,
                "column": 4
              },
              "end": {
                "line": 208,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value to test",
              "lineNumber": 2,
              "type": null,
              "name": "val"
            }
          ],
          "name": "Native",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Native"
          ]
        },
        {
          "description": "Determine whether a variable is a DOM Node",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 78,
              "column": 4
            },
            "end": {
              "line": 81,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 82,
                "column": 4
              },
              "end": {
                "line": 82,
                "column": 72
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Node",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Node"
          ]
        },
        {
          "description": "Determine whether a variable is a DOM NodeList or Collection of Nodes",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 83,
              "column": 4
            },
            "end": {
              "line": 86,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 87,
                "column": 4
              },
              "end": {
                "line": 87,
                "column": 137
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "NodeList",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "NodeList"
          ]
        },
        {
          "description": "Determine whether a variable is null",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 73,
              "column": 4
            },
            "end": {
              "line": 76,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 77,
                "column": 4
              },
              "end": {
                "line": 77,
                "column": 65
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Null",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Null"
          ]
        },
        {
          "description": "Test if something is a Number",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 48,
              "column": 4
            },
            "end": {
              "line": 51,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 52,
                "column": 4
              },
              "end": {
                "line": 52,
                "column": 70
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Num",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Num"
          ]
        },
        {
          "description": "Determine if a variable is an Object",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 88,
              "column": 4
            },
            "end": {
              "line": 91,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 92,
                "column": 4
              },
              "end": {
                "line": 92,
                "column": 83
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Object",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Object"
          ]
        },
        {
          "description": "Determines if a value is an instance of the ReactiveVariable class",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 196,
              "column": 4
            },
            "end": {
              "line": 199,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 200,
                "column": 4
              },
              "end": {
                "line": 200,
                "column": 111
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "ReactiveVariable",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "ReactiveVariable"
          ]
        },
        {
          "description": "Determine if a variable is a Regular Expression",
          "tags": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "loc": {
            "start": {
              "line": 123,
              "column": 4
            },
            "end": {
              "line": 126,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 127,
                "column": 4
              },
              "end": {
                "line": 127,
                "column": 47
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "name": "RegExp",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "RegExp"
          ]
        },
        {
          "description": "Determine if a variable is a Set",
          "tags": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "loc": {
            "start": {
              "line": 133,
              "column": 4
            },
            "end": {
              "line": 136,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 137,
                "column": 4
              },
              "end": {
                "line": 137,
                "column": 41
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "name": "Set",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Set"
          ]
        },
        {
          "description": "Test if something is a String",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 43,
              "column": 4
            },
            "end": {
              "line": 46,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 47,
                "column": 4
              },
              "end": {
                "line": 47,
                "column": 73
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "String",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "String"
          ]
        },
        {
          "description": "Determine if a variable is a Symbol",
          "tags": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "loc": {
            "start": {
              "line": 138,
              "column": 4
            },
            "end": {
              "line": 141,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 142,
                "column": 4
              },
              "end": {
                "line": 142,
                "column": 47
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": null,
              "name": "obj"
            }
          ],
          "name": "Symbol",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Symbol"
          ]
        },
        {
          "description": "Determine whether a variable is undefined",
          "tags": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "loc": {
            "start": {
              "line": 63,
              "column": 4
            },
            "end": {
              "line": 66,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 67,
                "column": 4
              },
              "end": {
                "line": 67,
                "column": 75
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value/values to test",
              "lineNumber": 2,
              "type": {
                "type": "RestType"
              },
              "name": "args"
            }
          ],
          "name": "Undef",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "Undef"
          ]
        },
        {
          "description": "Determine if a String (Single Character) is UPPERCASE",
          "tags": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "char"
            }
          ],
          "loc": {
            "start": {
              "line": 143,
              "column": 4
            },
            "end": {
              "line": 146,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 147,
                "column": 4
              },
              "end": {
                "line": 147,
                "column": 53
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "variable to test",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "char"
            }
          ],
          "name": "UpperCase",
          "kind": "function",
          "memberof": "is",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "is",
            "UpperCase"
          ]
        }
      ]
    },
    "path": [
      "is"
    ]
  },
  {
    "description": "Handles WebSockets in a contained manner with send and recieve methods",
    "tags": [],
    "loc": {
      "start": {
        "line": 290,
        "column": 2
      },
      "end": {
        "line": 290,
        "column": 79
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 291,
          "column": 2
        },
        "end": {
          "line": 326,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "CraftSocket",
    "kind": "class",
    "params": [
      {
        "title": "param",
        "name": "wsAddress",
        "lineNumber": 297
      },
      {
        "title": "param",
        "name": "protocols",
        "lineNumber": 297
      }
    ],
    "members": {
      "instance": [
        {
          "description": "Closes the WebSocket Connection",
          "tags": [],
          "loc": {
            "start": {
              "line": 322,
              "column": 4
            },
            "end": {
              "line": 322,
              "column": 42
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 323,
                "column": 4
              },
              "end": {
                "line": 325,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "close",
          "kind": "function",
          "memberof": "CraftSocket",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "CraftSocket",
            "close"
          ]
        },
        {
          "description": "Creates a new WebSocket connection",
          "tags": [
            {
              "title": "param",
              "description": "the WebSocket address example \"ws://localhost:3000/\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "wsAddress"
            },
            {
              "title": "param",
              "description": "the protocols to pass to the WebSocket Connection",
              "lineNumber": 3,
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                }
              },
              "name": "protocols"
            }
          ],
          "loc": {
            "start": {
              "line": 292,
              "column": 4
            },
            "end": {
              "line": 296,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 297,
                "column": 4
              },
              "end": {
                "line": 302,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "the WebSocket address example \"ws://localhost:3000/\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "wsAddress"
            },
            {
              "title": "param",
              "description": "the protocols to pass to the WebSocket Connection",
              "lineNumber": 3,
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                }
              },
              "name": "protocols"
            }
          ],
          "name": "constructor",
          "kind": "function",
          "memberof": "CraftSocket",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "CraftSocket",
            "constructor"
          ]
        },
        {
          "description": "Recieves messages from the WebSocket Server",
          "tags": [
            {
              "title": "param",
              "description": "function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "func"
            }
          ],
          "loc": {
            "start": {
              "line": 315,
              "column": 4
            },
            "end": {
              "line": 318,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 319,
                "column": 4
              },
              "end": {
                "line": 321,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "func"
            }
          ],
          "name": "recieve",
          "kind": "function",
          "memberof": "CraftSocket",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "CraftSocket",
            "recieve"
          ]
        },
        {
          "description": "Sends a message along the WebSocket Connection",
          "tags": [
            {
              "title": "param",
              "description": "the WebSocket address example \"ws://localhost:3000/\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "message"
            },
            {
              "title": "param",
              "description": "optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"",
              "lineNumber": 3,
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "function"
                }
              },
              "name": "func"
            }
          ],
          "loc": {
            "start": {
              "line": 303,
              "column": 4
            },
            "end": {
              "line": 307,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 308,
                "column": 4
              },
              "end": {
                "line": 314,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "the WebSocket address example \"ws://localhost:3000/\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "message"
            },
            {
              "title": "param",
              "description": "optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"",
              "lineNumber": 3,
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "function"
                }
              },
              "name": "func"
            }
          ],
          "name": "send",
          "kind": "function",
          "memberof": "CraftSocket",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "CraftSocket",
            "send"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "CraftSocket"
    ]
  },
  {
    "description": "Event handeling class",
    "tags": [],
    "loc": {
      "start": {
        "line": 372,
        "column": 2
      },
      "end": {
        "line": 372,
        "column": 30
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 373,
          "column": 2
        },
        "end": {
          "line": 415,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "EventHandler",
    "kind": "class",
    "params": [
      {
        "title": "param",
        "name": "EventType",
        "lineNumber": 382
      },
      {
        "title": "param",
        "name": "Target",
        "lineNumber": 382
      },
      {
        "title": "param",
        "name": "Func",
        "lineNumber": 382
      },
      {
        "title": "param",
        "name": "args",
        "type": {
          "type": "RestType"
        }
      }
    ],
    "members": {
      "instance": [
        {
          "description": "Creates new EventHandler",
          "tags": [
            {
              "title": "param",
              "description": "set the type of event to listen for example \"click\" or \"scroll\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "EventType"
            },
            {
              "title": "param",
              "description": "the Event Listener's target , can be a NodeList to listen on multiple Nodes",
              "lineNumber": 3,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Node"
                  },
                  {
                    "type": "NameExpression",
                    "name": "NodeList"
                  },
                  {
                    "type": "NameExpression",
                    "name": "window"
                  },
                  {
                    "type": "NameExpression",
                    "name": "document"
                  }
                ]
              },
              "name": "Target"
            },
            {
              "title": "param",
              "description": "Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "Func"
            },
            {
              "title": "param",
              "description": "extra optional arguments/parameters to pass to the handler function",
              "lineNumber": 5,
              "type": {
                "type": "RestType",
                "expression": {
                  "type": "AllLiteral"
                }
              },
              "name": "args"
            },
            {
              "title": "returns",
              "description": "Interface On,Off,Once",
              "lineNumber": 6,
              "type": null
            }
          ],
          "loc": {
            "start": {
              "line": 374,
              "column": 4
            },
            "end": {
              "line": 381,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 382,
                "column": 4
              },
              "end": {
                "line": 387,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "set the type of event to listen for example \"click\" or \"scroll\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "EventType"
            },
            {
              "title": "param",
              "description": "the Event Listener's target , can be a NodeList to listen on multiple Nodes",
              "lineNumber": 3,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Node"
                  },
                  {
                    "type": "NameExpression",
                    "name": "NodeList"
                  },
                  {
                    "type": "NameExpression",
                    "name": "window"
                  },
                  {
                    "type": "NameExpression",
                    "name": "document"
                  }
                ]
              },
              "name": "Target"
            },
            {
              "title": "param",
              "description": "Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "Func"
            },
            {
              "title": "param",
              "description": "extra optional arguments/parameters to pass to the handler function",
              "lineNumber": 5,
              "type": {
                "type": "RestType",
                "expression": {
                  "type": "AllLiteral"
                }
              },
              "name": "args"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "Interface On,Off,Once",
              "lineNumber": 6,
              "type": null
            }
          ],
          "name": "constructor",
          "kind": "function",
          "memberof": "EventHandler",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "EventHandler",
            "constructor"
          ]
        },
        {
          "description": "De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\ncan still optionally be re-activated with On again",
          "tags": [],
          "loc": {
            "start": {
              "line": 394,
              "column": 4
            },
            "end": {
              "line": 397,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 398,
                "column": 4
              },
              "end": {
                "line": 400,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "Off",
          "kind": "function",
          "memberof": "EventHandler",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "EventHandler",
            "Off"
          ]
        },
        {
          "description": "Activates the EventHandler to start listening for the EventType on the Target/Targets",
          "tags": [],
          "loc": {
            "start": {
              "line": 388,
              "column": 4
            },
            "end": {
              "line": 390,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 391,
                "column": 4
              },
              "end": {
                "line": 393,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "On",
          "kind": "function",
          "memberof": "EventHandler",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "EventHandler",
            "On"
          ]
        },
        {
          "description": "Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\nthe Handler function will be called only Once",
          "tags": [],
          "loc": {
            "start": {
              "line": 401,
              "column": 4
            },
            "end": {
              "line": 404,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 405,
                "column": 4
              },
              "end": {
                "line": 414,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "Once",
          "kind": "function",
          "memberof": "EventHandler",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "EventHandler",
            "Once"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "EventHandler"
    ]
  },
  {
    "description": "Variable that is used for Data Binding and other reactive processes",
    "tags": [],
    "loc": {
      "start": {
        "line": 328,
        "column": 2
      },
      "end": {
        "line": 330,
        "column": 4
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 331,
          "column": 2
        },
        "end": {
          "line": 370,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "ReactiveVariable",
    "kind": "class",
    "params": [
      {
        "title": "param",
        "name": "val",
        "lineNumber": 338
      },
      {
        "title": "param",
        "name": "handle",
        "lineNumber": 338
      }
    ],
    "members": {
      "instance": [
        {
          "description": "Creates a ReactiveVariable",
          "tags": [
            {
              "title": "param",
              "description": "value you'd liek the ReactiveVariable to Store",
              "lineNumber": 2,
              "type": {
                "type": "AllLiteral"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "handle"
            },
            {
              "title": "returns",
              "description": "Returns the value assigned to the ReactiveVariable",
              "lineNumber": 4,
              "type": {
                "type": "AllLiteral"
              }
            }
          ],
          "loc": {
            "start": {
              "line": 332,
              "column": 4
            },
            "end": {
              "line": 337,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 338,
                "column": 4
              },
              "end": {
                "line": 344,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "value you'd liek the ReactiveVariable to Store",
              "lineNumber": 2,
              "type": {
                "type": "AllLiteral"
              },
              "name": "val"
            },
            {
              "title": "param",
              "description": "function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "handle"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "Returns the value assigned to the ReactiveVariable",
              "lineNumber": 4,
              "type": {
                "type": "AllLiteral"
              }
            }
          ],
          "name": "constructor",
          "kind": "function",
          "memberof": "ReactiveVariable",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ReactiveVariable",
            "constructor"
          ]
        },
        {
          "description": "Gets the value of the ReactiveVariable , ReactiveVariable.val also does this",
          "tags": [],
          "loc": {
            "start": {
              "line": 357,
              "column": 4
            },
            "end": {
              "line": 359,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 360,
                "column": 4
              },
              "end": {
                "line": 362,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "get",
          "kind": "function",
          "memberof": "ReactiveVariable",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ReactiveVariable",
            "get"
          ]
        },
        {
          "description": "Redefine the handle function of the ReactiveVariable",
          "tags": [
            {
              "title": "param",
              "description": "function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "handle"
            }
          ],
          "loc": {
            "start": {
              "line": 363,
              "column": 4
            },
            "end": {
              "line": 366,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 367,
                "column": 4
              },
              "end": {
                "line": 369,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "handle"
            }
          ],
          "name": "reset",
          "kind": "function",
          "memberof": "ReactiveVariable",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ReactiveVariable",
            "reset"
          ]
        },
        {
          "description": "Sets the new value of the ReactiveVariable , this will also call the handle function",
          "tags": [
            {
              "title": "param",
              "description": "new value to assign the ReactiveVariable",
              "lineNumber": 2,
              "type": {
                "type": "AllLiteral"
              },
              "name": "val"
            }
          ],
          "loc": {
            "start": {
              "line": 345,
              "column": 4
            },
            "end": {
              "line": 348,
              "column": 6
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 349,
                "column": 4
              },
              "end": {
                "line": 356,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "params": [
            {
              "title": "param",
              "description": "new value to assign the ReactiveVariable",
              "lineNumber": 2,
              "type": {
                "type": "AllLiteral"
              },
              "name": "val"
            }
          ],
          "name": "set",
          "kind": "function",
          "memberof": "ReactiveVariable",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ReactiveVariable",
            "set"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "ReactiveVariable"
    ]
  },
  {
    "description": "Craft - Crafter.js Core Object containing most methods",
    "tags": [],
    "loc": {
      "start": {
        "line": 647,
        "column": 2
      },
      "end": {
        "line": 649,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 650,
          "column": 2
        },
        "end": {
          "line": 1054,
          "column": 4
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "name": "Craft",
    "kind": "function",
    "params": [
      {
        "title": "param",
        "name": "arr",
        "lineNumber": 651
      }
    ],
    "members": {
      "instance": [],
      "static": [
        {
          "description": "creates a new bound variable , part of Crafter.js's Data Binding System",
          "tags": [],
          "loc": {
            "start": {
              "line": 1040,
              "column": 4
            },
            "end": {
              "line": 1040,
              "column": 82
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 1041,
                "column": 4
              },
              "end": {
                "line": 1046,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "newBind",
          "kind": "function",
          "params": [
            {
              "title": "param",
              "name": "key",
              "lineNumber": 1041
            },
            {
              "title": "param",
              "name": "val",
              "lineNumber": 1041
            },
            {
              "title": "param",
              "name": "handle",
              "lineNumber": 1041
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "newBind"
          ]
        },
        {
          "description": "method for creating custom elements\nconfiguring their lifecycle's and inheritance",
          "tags": [],
          "loc": {
            "start": {
              "line": 1018,
              "column": 4
            },
            "end": {
              "line": 1021,
              "column": 7
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 1022,
                "column": 4
              },
              "end": {
                "line": 1039,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "newComponent",
          "kind": "function",
          "params": [
            {
              "title": "param",
              "name": "tag",
              "lineNumber": 1022
            },
            {
              "title": "param",
              "name": "config",
              "lineNumber": 1022
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "newComponent"
          ]
        },
        {
          "description": "method for generating random alphanumeric strings",
          "tags": [],
          "loc": {
            "start": {
              "line": 1005,
              "column": 4
            },
            "end": {
              "line": 1005,
              "column": 59
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 1006,
                "column": 4
              },
              "end": {
                "line": 1006,
                "column": 91
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "randomString",
          "kind": "function",
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "randomString"
          ]
        },
        {
          "description": "sets the value of a bound variable",
          "tags": [],
          "loc": {
            "start": {
              "line": 1047,
              "column": 4
            },
            "end": {
              "line": 1047,
              "column": 45
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 1048,
                "column": 4
              },
              "end": {
                "line": 1053,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "setBind",
          "kind": "function",
          "params": [
            {
              "title": "param",
              "name": "key",
              "lineNumber": 1048
            },
            {
              "title": "param",
              "name": "val",
              "lineNumber": 1048
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "setBind"
          ]
        },
        {
          "description": "Usefull method for validating passwords",
          "tags": [],
          "loc": {
            "start": {
              "line": 989,
              "column": 4
            },
            "end": {
              "line": 991,
              "column": 7
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 992,
                "column": 4
              },
              "end": {
                "line": 1004,
                "column": 5
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "name": "strongPassword",
          "kind": "function",
          "params": [
            {
              "title": "param",
              "name": "pass",
              "lineNumber": 992
            },
            {
              "title": "param",
              "name": "length",
              "lineNumber": 992
            },
            {
              "title": "param",
              "name": "caps",
              "lineNumber": 992
            },
            {
              "title": "param",
              "name": "number",
              "lineNumber": 992
            },
            {
              "title": "param",
              "name": "includeChars",
              "type": {
                "type": "RestType"
              }
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "strongPassword"
          ]
        },
        {
          "description": "function that returns a promise when the DOM and WebComponents are finished loading",
          "tags": [
            {
              "title": "namespace",
              "description": null,
              "lineNumber": 2,
              "type": null,
              "name": "Craft"
            }
          ],
          "loc": {
            "start": {
              "line": 949,
              "column": 4
            },
            "end": {
              "line": 952,
              "column": 7
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 953,
                "column": 4
              },
              "end": {
                "line": 969,
                "column": 6
              }
            },
            "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
            "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
          },
          "namespace": {
            "name": "Craft"
          },
          "name": "WhenReady",
          "kind": "namespace",
          "params": [
            {
              "title": "param",
              "name": "Scope",
              "lineNumber": 953
            }
          ],
          "memberof": "Craft",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Craft",
            "WhenReady"
          ]
        }
      ]
    },
    "path": [
      "Craft"
    ]
  },
  {
    "description": "Function that returns many useful methods for interacting with and manipulating the DOM or creating elements",
    "tags": [
      {
        "title": "param",
        "description": "optional Node, NodeList or CSS Selector that will be affected by the methods returned",
        "lineNumber": 2,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "Node"
              },
              {
                "type": "NameExpression",
                "name": "NodeList"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "element"
      }
    ],
    "loc": {
      "start": {
        "line": 529,
        "column": 2
      },
      "end": {
        "line": 532,
        "column": 4
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 533,
          "column": 2
        },
        "end": {
          "line": 645,
          "column": 4
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "params": [
      {
        "title": "param",
        "description": "optional Node, NodeList or CSS Selector that will be affected by the methods returned",
        "lineNumber": 2,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "Node"
              },
              {
                "type": "NameExpression",
                "name": "NodeList"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "element"
      }
    ],
    "name": "dom",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "dom"
    ]
  },
  {
    "description": "Easy way to loop through Collections and Objects",
    "tags": [
      {
        "title": "param",
        "description": "any collection that is either an Object or has a .length value",
        "lineNumber": 2,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "Object"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            }
          ]
        },
        "name": "iterable"
      },
      {
        "title": "param",
        "description": "function called on each iteration -> \"function( value , indexOrKey ) {...}\"",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "func"
      }
    ],
    "loc": {
      "start": {
        "line": 417,
        "column": 2
      },
      "end": {
        "line": 421,
        "column": 4
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 422,
          "column": 2
        },
        "end": {
          "line": 431,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "params": [
      {
        "title": "param",
        "description": "any collection that is either an Object or has a .length value",
        "lineNumber": 2,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "Object"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            }
          ]
        },
        "name": "iterable"
      },
      {
        "title": "param",
        "description": "function called on each iteration -> \"function( value , indexOrKey ) {...}\"",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "func"
      }
    ],
    "name": "forEach",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "forEach"
    ]
  },
  {
    "description": "Starts listening for an EventType on the Target/Targets",
    "tags": [
      {
        "title": "param",
        "description": "set the type of event to listen for example \"click\" or \"scroll\"",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "EventType"
      },
      {
        "title": "param",
        "description": "the Event Listener's target , can be a NodeList to listen on multiple Nodes",
        "lineNumber": 3,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Node"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            },
            {
              "type": "NameExpression",
              "name": "window"
            },
            {
              "type": "NameExpression",
              "name": "document"
            }
          ]
        },
        "name": "Target"
      },
      {
        "title": "param",
        "description": "Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"",
        "lineNumber": 4,
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "Func"
      },
      {
        "title": "returns",
        "description": "Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On",
        "lineNumber": 5,
        "type": null
      }
    ],
    "loc": {
      "start": {
        "line": 471,
        "column": 2
      },
      "end": {
        "line": 477,
        "column": 4
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 478,
          "column": 2
        },
        "end": {
          "line": 486,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "params": [
      {
        "title": "param",
        "description": "set the type of event to listen for example \"click\" or \"scroll\"",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "EventType"
      },
      {
        "title": "param",
        "description": "the Event Listener's target , can be a NodeList to listen on multiple Nodes",
        "lineNumber": 3,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Node"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            },
            {
              "type": "NameExpression",
              "name": "window"
            },
            {
              "type": "NameExpression",
              "name": "document"
            }
          ]
        },
        "name": "Target"
      },
      {
        "title": "param",
        "description": "Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"",
        "lineNumber": 4,
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "Func"
      },
      {
        "title": "param",
        "name": "func",
        "lineNumber": 478
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On",
        "lineNumber": 5,
        "type": null
      }
    ],
    "name": "On",
    "kind": "class",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "On"
    ]
  },
  {
    "description": "Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening",
    "tags": [
      {
        "title": "param",
        "description": "set the type of event to listen for example \"click\" or \"scroll\"",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "EventType"
      },
      {
        "title": "param",
        "description": "the Event Listener's target , can be a NodeList to listen on multiple Nodes",
        "lineNumber": 3,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Node"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            },
            {
              "type": "NameExpression",
              "name": "window"
            },
            {
              "type": "NameExpression",
              "name": "document"
            }
          ]
        },
        "name": "Target"
      },
      {
        "title": "param",
        "description": "Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"",
        "lineNumber": 4,
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "Func"
      },
      {
        "title": "returns",
        "description": "On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On",
        "lineNumber": 5,
        "type": null
      }
    ],
    "loc": {
      "start": {
        "line": 488,
        "column": 2
      },
      "end": {
        "line": 494,
        "column": 4
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 495,
          "column": 2
        },
        "end": {
          "line": 503,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "params": [
      {
        "title": "param",
        "description": "set the type of event to listen for example \"click\" or \"scroll\"",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "EventType"
      },
      {
        "title": "param",
        "description": "the Event Listener's target , can be a NodeList to listen on multiple Nodes",
        "lineNumber": 3,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Node"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            },
            {
              "type": "NameExpression",
              "name": "window"
            },
            {
              "type": "NameExpression",
              "name": "document"
            }
          ]
        },
        "name": "Target"
      },
      {
        "title": "param",
        "description": "Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"",
        "lineNumber": 4,
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "Func"
      },
      {
        "title": "param",
        "name": "func",
        "lineNumber": 495
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On",
        "lineNumber": 5,
        "type": null
      }
    ],
    "name": "Once",
    "kind": "class",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "Once"
    ]
  },
  {
    "description": "Easy way to get a DOM Node or Node within another DOM Node using CSS selectors",
    "tags": [
      {
        "title": "param",
        "description": "CSS selector to query the DOM Node with",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "selector"
      },
      {
        "title": "param",
        "description": "Optional Node or CSS selector to search within insead of document",
        "lineNumber": 3,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "Node"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "element"
      }
    ],
    "loc": {
      "start": {
        "line": 433,
        "column": 2
      },
      "end": {
        "line": 437,
        "column": 4
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 438,
          "column": 2
        },
        "end": {
          "line": 442,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "params": [
      {
        "title": "param",
        "description": "CSS selector to query the DOM Node with",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "selector"
      },
      {
        "title": "param",
        "description": "Optional Node or CSS selector to search within insead of document",
        "lineNumber": 3,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "Node"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "element"
      }
    ],
    "name": "query",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "query"
    ]
  },
  {
    "description": "Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors",
    "tags": [
      {
        "title": "param",
        "description": "CSS selector to query the DOM Nodes with",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "selector"
      },
      {
        "title": "param",
        "description": "Optional Node or CSS selector to search within insead of document",
        "lineNumber": 3,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "Node"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "element"
      }
    ],
    "loc": {
      "start": {
        "line": 443,
        "column": 2
      },
      "end": {
        "line": 447,
        "column": 4
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 448,
          "column": 2
        },
        "end": {
          "line": 452,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "params": [
      {
        "title": "param",
        "description": "CSS selector to query the DOM Nodes with",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "selector"
      },
      {
        "title": "param",
        "description": "Optional Node or CSS selector to search within insead of document",
        "lineNumber": 3,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "Node"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "element"
      }
    ],
    "name": "queryAll",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "queryAll"
    ]
  },
  {
    "description": "Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList",
    "tags": [
      {
        "title": "param",
        "description": "CSS selector to query the DOM Nodes with or NodeList to iterate through",
        "lineNumber": 2,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            }
          ]
        },
        "name": "selector"
      },
      {
        "title": "param",
        "description": "Optional Node or CSS selector to search within insead of document",
        "lineNumber": 3,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "Node"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "element"
      },
      {
        "title": "param",
        "description": "function called on each iteration -> \"function( Element , index ) {...}\"",
        "lineNumber": 4,
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "func"
      }
    ],
    "loc": {
      "start": {
        "line": 453,
        "column": 2
      },
      "end": {
        "line": 458,
        "column": 4
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 459,
          "column": 2
        },
        "end": {
          "line": 469,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "params": [
      {
        "title": "param",
        "description": "CSS selector to query the DOM Nodes with or NodeList to iterate through",
        "lineNumber": 2,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            }
          ]
        },
        "name": "selector"
      },
      {
        "title": "param",
        "description": "Optional Node or CSS selector to search within insead of document",
        "lineNumber": 3,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "Node"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "element"
      },
      {
        "title": "param",
        "description": "function called on each iteration -> \"function( Element , index ) {...}\"",
        "lineNumber": 4,
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "func"
      }
    ],
    "name": "queryEach",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "queryEach"
    ]
  },
  {
    "description": "Converts any Query/QueryAll to an Array of Nodes even if there is only one Node",
    "tags": [
      {
        "title": "param",
        "description": "pass either a CSS Selector string , Node/NodeList or Array of Nodes",
        "lineNumber": 2,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Node"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        },
        "name": "val"
      }
    ],
    "loc": {
      "start": {
        "line": 211,
        "column": 2
      },
      "end": {
        "line": 214,
        "column": 4
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 215,
          "column": 2
        },
        "end": {
          "line": 219,
          "column": 3
        }
      },
      "file": "/home/saul/Documents/Crafterjs/src/Crafter.js",
      "code": "/** @license MIT\n *  @overview Crafter.js , minimalist front-end library\n *  @author Saul van der Walt - https://github.com/SaulDoesCode/\n */\n\"use strict\";\n((doc, root) => {\n\n  let type = (obj, str) => toString.call(obj) === str,\n    isT = (val, str) => typeof val === str,\n    nT = (val, str) => !isT(val, str),\n    eachisInstanceof = (test, collection) => {\n      if (isT(collection, 'string') || collection === undefined || collection === null) return false;\n      let i = 0,\n        allgood = true;\n      for (; i < collection.length; i++) {\n        if (collection[i] instanceof test) {\n          allgood = false;\n          break;\n        }\n      }\n      return allgood;\n    },\n    Ready = false,\n    head = doc.getElementsByTagName('head')[0],\n    CrafterStyles = doc.createElement('style'),\n    ua = navigator.userAgent,\n    tem, _br = ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n  if (_br && (tem = ua.match(/version\\/([\\.\\d]+)/i)) !== null) _br[2] = tem[1];\n  _br ? [_br[1], _br[2]] : [navigator.appName, navigator.appVersion, '-?'];\n\n  CrafterStyles.setAttribute('crafterstyles', '');\n  CrafterStyles.innerHTML = `\\n@keyframes NodeInserted {from {opacity:.99;}to {opacity: 1;}} [view-bind] {animation-duration: 0.001s;animation-name: NodeInserted;}`;\n  head.appendChild(CrafterStyles);\n  CrafterStyles = doc.querySelector('[crafterstyles]', head);\n\n  /** is - Type Testing / Assertion */\n  var is = {\n    /**\n    * Test if something is a boolean type\n    * @param val - value to test\n    */\n    Bool: val => typeof val === 'boolean',\n    /**\n    * Test if something is a String\n    * @param args - value/values to test\n    */\n    String: (...args) => args.length && args.every(o => isT(o, 'string')),\n    /**\n    * Test if something is a Number\n    * @param args - value/values to test\n    */\n    Num: (...args) => args.length && args.every(o => isT(o, 'number')),\n    /**\n    * Test if something is an Array\n    * @param args - value/values to test\n    */\n    Arr: (...args) => args.length && args.every(o => Array.isArray(o)),\n    /**\n    * Test if something is an Array-Like\n    * @param args - value/values to test\n    */\n    Arraylike: (...args) => args.length && args.every(o => is.Def(o.length) ? true : false),\n    /**\n    * Determine whether a variable is undefined\n    * @param args - value/values to test\n    */\n    Undef: (...args) => args.length && args.every(o => isT(o, 'undefined')),\n    /**\n    * Determine whether a variable is in fact defined\n    * @param args - value/values to test\n    */\n    Def: (...args) => args.length && args.every(o => nT(o, 'undefined')),\n    /**\n    * Determine whether a variable is null\n    * @param args - value/values to test\n    */\n    Null: (...args) => args.length && args.every(o => o === null),\n    /**\n    * Determine whether a variable is a DOM Node\n    * @param args - value/values to test\n    */\n    Node: (...args) => args.length && args.every(o => o instanceof Node),\n    /**\n    * Determine whether a variable is a DOM NodeList or Collection of Nodes\n    * @param args - value/values to test\n    */\n    NodeList: (...args) => args.length ? args.every(n => n === null ? false : n instanceof NodeList || eachisInstanceof(Node, n)) : false,\n    /**\n    * Determine if a variable is an Object\n    * @param args - value/values to test\n    */\n    Object: (...args) => args.length && args.every(o => type(o, '[object Object]')),\n    /**\n    * Determine if a variable is a HTMLElement\n    * @param args - value/values to test\n    */\n    Element: (...args) => args.length && args.every(o => type(o, '[object HTMLElement]')),\n    /**\n    * Determine if a variable is a File Object\n    * @param args - value/values to test\n    */\n    File: (...args) => args.length && args.every(o => type(o, '[object File]')),\n    /**\n    * Determine if a variable is of a FormData type\n    * @param args - value/values to test\n    */\n    FormData: (...args) => args.length && args.every(o => type(o, '[object FormData]')),\n    /**\n    * Determine if a variable is a Map\n    * @param args - value/values to test\n    */\n    Map: (...args) => args.length && args.every(o => type(o, '[object Map]')),\n    /**\n    * Determine if a variable is a function\n    * @param args - value/values to test\n    */\n    Func: (...args) => args.length && args.every(o => typeof o === 'function'),\n    /**\n    * Determine if a variable is of Blob type\n    * @param obj - variable to test\n    */\n    Blob: obj => type(obj, '[object Blob]'),\n    /**\n    * Determine if a variable is a Regular Expression\n    * @param obj - variable to test\n    */\n    RegExp: obj => type(obj, '[object RegExp]'),\n    /**\n    * Determine if a variable is a Date type\n    * @param obj - variable to test\n    */\n    Date: obj => type(obj, '[object Date]'),\n    /**\n    * Determine if a variable is a Set\n    * @param obj - variable to test\n    */\n    Set: obj => type(obj, '[object Set]'),\n    /**\n    * Determine if a variable is a Symbol\n    * @param obj - variable to test\n    */\n    Symbol: obj => type(obj, '[object Symbol]'),\n    /**\n    * Determine if a String (Single Character) is UPPERCASE\n    * @param {string} char - variable to test\n    */\n    UpperCase: char => (char >= 'A') && (char <= 'Z'),\n    /**\n    * Determine if a String contains only characters and numbers (alphanumeric)\n    * @param {string} str - variable to test\n    */\n    Alphanumeric: str => /^[0-9a-zA-Z]+$/.test(str),\n    /**\n    * Determines whether a String is a valid Email\n    * @param {string} email - variable to test\n    */\n    Email: email => /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/.test(email),\n    /**\n    * Determines whether a Number is between a maximum and a minimum\n    * @param {Number} val - number value to test\n    * @param {Number} max - maximum to compare the value with\n    * @param {Number} min - minimum to compare the value with\n    * @returns {Boolean} wether or not the value is between the max and min\n    */\n    Between: (val, max, min) => (val <= max && val >= min),\n    /**\n    * Determines if two variables are equal\n    * @param a - first value to compare\n    * @param b - second value to compare\n    */\n    eq: (a, b) => a === b,\n    /**\n    * Determines if a number is LOWER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lt: (val, other) => val < other,\n    /**\n    * Determines if a number is LOWER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    lte: (val, other) => val <= other,\n    /**\n    * Determines if a number is BIGGER than another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bt: (val, other) => val > other,\n    /**\n    * Determines if a number is BIGGER than or equal to another\n    * @param {Number} val - value to test\n    * @param {Number} other - num to test with value\n    */\n    bte: (val, other) => val >= other,\n    /**\n    * Determines if a value is an instance of the ReactiveVariable class\n    * @param args - value/values to test\n    */\n    ReactiveVariable: (...args) => args.length && args.every(o => o instanceof ReactiveVariable ? true : false),\n    /**\n    * Test if something is a Native JavaScript feature\n    * @param val - value to test\n    */\n    Native: val => {\n      let type = typeof val;\n      return type === 'function' ? RegExp('^' + String(Object.prototype.toString).replace(/[.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&').replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$').test(Function.prototype.toString.call(val)) : (val && type == 'object' && /^\\[object .+?Constructor\\]$/.test(val.toString)) || false;\n    },\n  };\n\n  /**\n  * Converts any Query/QueryAll to an Array of Nodes even if there is only one Node\n  * @param {Node|NodeList|Array|String} val - pass either a CSS Selector string , Node/NodeList or Array of Nodes\n  */\n  function QueryOrNodetoNodeArray(val) {\n    if (is.String(val)) val = queryAll(val);\n    if (is.Node(val)) return [val];\n    else if (is.NodeList(val)) return Array.from(val);\n  }\n\n  /**\n   * associative collection of functions\n   * that can be added,removed or iterated through\n   */\n  class FunctionIterator {\n    constructor() {\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Check if the FunctionIterator Collection contains a certain function\n    * @param {string} funcName - name to identify the function with\n    */\n    has(funcName) {\n      if (this.functions.has(funcName)) return true;\n      return false;\n    }\n    /**\n    * Add a function to the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {Function} func - function to be stored in the FunctionIterator Collection\n    */\n    add(funcName, func) {\n      if (is.Func(func)) {\n        this.functions[funcName] = func;\n      } else if (is.Func(funcName)) {\n        this.functions[Craft.randomString()] = funcName;\n      } else console.error(\"Invalid function parameter in FunctionIterator.add(funcName , _function_ )\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove a function from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    remove(funcName) {\n      if (this.functions.has(funcName)) {\n        this.functions[funcName] = null;\n        delete this.functions[funcName];\n      } else console.warn(\"No Such Function Entry in FunctionIterator\");\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Remove all functions from the collection\n    * @param {string} funcName - name to identify the function with\n    */\n    removeAll() {\n      delete this.functions;\n      this.functions = null;\n      this.functions = {};\n      this.length = Object.keys(this.functions).length;\n    }\n    /**\n    * Execute each function in the Collection\n    * all arguments passed will be applied to each function in the collection\n    * usefull for centralizing an Event Listener such as a Window Resize event\n    */\n    runEach() {\n      for (let i in this.functions) this.functions[i].apply(this, arguments);\n    }\n    /**\n    * Execute a single function in the collection\n    * @param {string} funcName - name to identify the function with\n    * @param {...*=} args - arguments/parameters to pass to the function\n    */\n    runOne(funcName, ...arg) {\n      this.functions.hasOwnProperty(funcName) ? this.functions[funcName].apply(this, args) : console.warn(\"No Such Function Entry in FunctionIterator\");\n    }\n  }\n\n  /** Handles WebSockets in a contained manner with send and recieve methods */\n  class CraftSocket {\n    /**\n    * Creates a new WebSocket connection\n    * @param {string} wsAddress - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {Array=} protocols - the protocols to pass to the WebSocket Connection\n    */\n    constructor(wsAddress, protocols) {\n      is.Arr(protocols) ? this.Socket = new WebSocket(wsAddress, protocols) : this.Socket = new WebSocket(wsAddress);\n      this.messageCalls = [];\n      this.RecieveCalls = [];\n      this.Socket.onmessage = e => this.RecieveCalls.forEach(call => call(e));\n    }\n    /**\n    * Sends a message along the WebSocket Connection\n    * @param {string} message - the WebSocket address example \"ws://localhost:3000/\"\n    * @param {function=} func - optional function to recieve the response with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    send(message, func) {\n      this.messageCalls.push(() => {\n        this.Socket.send(message);\n        if (is.Def(func) && is.Func(func)) this.recieve((data, e) => func(data, e));\n      });\n      this.Socket.onopen = e => this.messageCalls[this.messageCalls.length - 1]();\n    }\n    /**\n    * Recieves messages from the WebSocket Server\n    * @param {function} func - function to recieve the response and event with -> \"function ( response , event ) { ... } or response => ...\"\n    */\n    recieve(func) {\n      is.Func(func) ? this.RecieveCalls.push(e => func(e.data, e)) : console.error(\"callback is not a function or is not defined\")\n    }\n    /** Closes the WebSocket Connection */\n    close() {\n      this.Socket.close()\n    }\n  }\n\n  /**\n  * Variable that is used for Data Binding and other reactive processes\n  */\n  class ReactiveVariable {\n    /**\n    * Creates a ReactiveVariable\n    * @param {*} val - value you'd liek the ReactiveVariable to Store\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    * @returns {*} Returns the value assigned to the ReactiveVariable\n    */\n    constructor(val, handle) {\n      if (is.Func(handle)) {\n        this.val = val;\n        this.Handle = handle;\n      } else console.error('ReactiveVariable needs a handler function after the value');\n      return this.val\n    }\n    /**\n    * Sets the new value of the ReactiveVariable , this will also call the handle function\n    * @param {*} val - new value to assign the ReactiveVariable\n    */\n    set(val) {\n      if (this.val !== val) {\n        this.Oldval = this.val;\n        this.val = val;\n        this.Handle(this.Oldval, val);\n      }\n      return this.val;\n    }\n    /**\n    * Gets the value of the ReactiveVariable , ReactiveVariable.val also does this\n    */\n    get() {\n      return this.val\n    }\n    /**\n    * Redefine the handle function of the ReactiveVariable\n    * @param {function} handle - function that gets called whenever the ReactiveVariable changes -> \"function( OldValue , newValue ) {...}\"\n    */\n    reset(handle) {\n      is.Func(handle) ? this.Handle = handle : console.error('ReactiveVariable.Reset only takes a function');\n    }\n  }\n\n  /** Event handeling class */\n  class EventHandler {\n    /**\n    * Creates new EventHandler\n    * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n    * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n    * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n    * @param {...*} args - extra optional arguments/parameters to pass to the handler function\n    * @returns Interface On,Off,Once\n    */\n    constructor(EventType, Target, Func, ...args) {\n      this.EventType = EventType;\n      this.Func = Func;\n      this.Target = (Target !== window && Target !== document) ? QueryOrNodetoNodeArray(Target) : Target;\n      this.FuncWrapper = e => Func(e, e.srcElement, args || []);\n    }\n    /**\n    * Activates the EventHandler to start listening for the EventType on the Target/Targets\n    */\n    On() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.addEventListener(this.EventType, this.FuncWrapper)) : this.Target.addEventListener(this.EventType, this.FuncWrapper)\n    }\n    /**\n    * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets\n    * can still optionally be re-activated with On again\n    */\n    Off() {\n      is.Arr(this.Target) ? this.Target.forEach(target => target.removeEventListener(this.EventType, this.FuncWrapper)) : this.Target.removeEventListener(this.EventType, this.FuncWrapper);\n    }\n    /**\n    * Once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets\n    * the Handler function will be called only Once\n    */\n    Once() {\n      let func = this.FuncWrapper,\n        target = this.Target,\n        etype = this.EventType,\n        listenOnce = e => {\n          func(e);\n          is.Arr(target) ? target.forEach(t => t.removeEventListener(etype, listenOnce)) : target.removeEventListener(etype, listenOnce);\n        }\n      is.Arr(target) ? target.forEach(t => t.addEventListener(etype, listenOnce)) : target.addEventListener(etype, listenOnce);\n    }\n  }\n\n  /**\n  * Easy way to loop through Collections and Objects\n  * @param {Array|Object|NodeList} iterable - any collection that is either an Object or has a .length value\n  * @param {function} func - function called on each iteration -> \"function( value , indexOrKey ) {...}\"\n  */\n  function forEach(iterable, func) {\n    if (is.Undef(iterable)) throw new Error(\"forEach -> cannot iterate through undefined\");\n    if (!is.Func(func)) throw new Error(\"forEach -> invalid or undefined function provided\");\n    let i = 0;\n    if (is.Def(iterable.length))\n      for (; i < iterable.length; i++) func(iterable[i], i);\n    else\n      for (i in iterable)\n        if (iterable.hasOwnProperty(i)) func(iterable[i], i)\n  }\n\n  /**\n  * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Node with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function query(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelector(selector);\n    if (is.Node(element)) return element.querySelector(selector);\n    return doc.querySelector(selector);\n  }\n  /**\n  * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors\n  * @param {string} selector - CSS selector to query the DOM Nodes with\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  */\n  function queryAll(selector, element) {\n    if (is.String(element)) return doc.querySelector(element).querySelectorAll(selector);\n    if (is.Node(element)) return element.querySelectorAll(selector);\n    return doc.querySelectorAll(selector);\n  }\n  /**\n  * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList\n  * @param {string|NodeList} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through\n  * @param {Node|string=} element - Optional Node or CSS selector to search within insead of document\n  * @param {function} func - function called on each iteration -> \"function( Element , index ) {...}\"\n  */\n  function queryEach(selector, element, func) {\n    if (is.Func(element)) {\n      func = element;\n      element = doc;\n    }\n    let elements, i = 0;\n    if (is.String(element, selector)) elements = doc.querySelector(element).querySelectorAll(selector);\n    if (is.String(selector)) elements = element.querySelectorAll(selector);\n    if (is.NodeList(selector) || is.Element(selector)) elements = [selector];\n    for (; i < elements.length; i++) func(elements[i], i);\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns Off - when On is defined as a variable \"var x = On(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function On(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.On();\n    return handle;\n  }\n\n  /**\n  * Starts listening for an EventType on the Target/Targets ONCE after triggering the Once event Listener will stop listening\n  * @param {string} EventType - set the type of event to listen for example \"click\" or \"scroll\"\n  * @param {Node|NodeList|window|document} Target - the Event Listener's target , can be a NodeList to listen on multiple Nodes\n  * @param {function} Func - Handler function that will be called when the event is triggered -> \"function( event , event.srcElement ) {...}\"\n  * @returns On,Off,Once - when Once is defined as a variable \"var x = Once(...)\" it allows you to access all the EventHandler interfaces Off,Once,On\n  */\n  function Once(EventType, Target, func) {\n    if (is.Func(Target)) {\n      func = Target;\n      Target = root;\n    }\n    let handle = new EventHandler(EventType, Target, func);\n    handle.Once();\n    return handle;\n  }\n\n  function make_element(name, inner, attributes, NodeForm, extraAttr) {\n    if (is.Bool(attributes)) {\n      NodeForm = attributes;\n      attributes = undefined;\n    }\n    if (is.Bool(inner)) {\n      NodeForm = inner;\n      attributes = undefined;\n    }\n    if (NodeForm === true) {\n      let newEl = doc.createElement(name);\n      newEl.innerHTML = inner;\n      if (is.Object(attributes)) forEach(attributes, (val, attr) => newEl.setAttribute(attr, val));\n      if (is.String(attributes)) attributes.split('&').forEach(attr => is.Def(attr.split('=')[1]) ? newEl.setAttribute(attr.split('=')[0], attr.split('=')[1]) : newEl.setAttribute(attr.split('=')[0], ''));\n      if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => newEl.setAttribute(attr, val));\n      return newEl;\n    }\n    let attrString = ``;\n    if (is.String(attributes)) attributes.split('&').forEach(attr => attrString += is.Def(attr.split('=')[1]) ? `${attr.split('=')[0]}=\"${attr.split('=')[1]}\" ` : `${attr.split('=')[0]} `);\n    if (is.Object(attributes)) forEach(attributes, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    if (is.Def(extraAttr) && is.Object(extraAttr)) forEach(extraAttr, (val, attr) => attrString += ` ${attr}=\"${val}\" `);\n    return `<${name} ${attrString}>${inner}</${name}>`;\n  }\n\n  /**\n  * Function that returns many useful methods for interacting with and manipulating the DOM or creating elements\n  * @param {Node|NodeList|string=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned\n  */\n  var dom = element => {\n    if (is.String(element)) {\n      let elements = queryAll(element);\n      (elements.length > 1) ? element = elements: element = elements[0];\n    }\n    if (is.Node(element)) return {\n      html: val => val ? element.innerHTML = val : element.innerHTML,\n      text: val => val ? element.textContent = val : element.textContent,\n      replace: val => element.parentNode.replaceChild(el, element),\n      remove: () => element.parentNode.removeChild(element),\n      appendTo: val => {\n        let el;\n        is.Node(val) ? el = val : el = query(val);\n        if (el !== null) el.appendChild(element);\n      },\n      append: val => is.String(val) ? element.innerHTML += val : element.parentNode.appendChild(element),\n      prepend: val => is.String(val) ? element.innerHTML = val + element.innerHTML : element.insertBefore(val, element.firstChild),\n      On: (eventType, func) => On(eventType, element, func),\n      css: styles => is.Def(styles) ? forEach(styles, (prop, key) => element.style[key] = prop) : console.error('Styles Object undefined'),\n      gotClass: CSSclass => element.classList.contains(CSSclass),\n      addClass: CSSclass => element.classList.add(CSSclass),\n      stripClass: CSSclass => element.classList.remove(CSSclass),\n      stripAttr: Attr => element.removeAttribute(Attr),\n      hasAttr: Attr => element.hasAttribute(Attr),\n      setAttr: (Attr, val) => element.setAttribute(Attr, val),\n      getAttr: Attr => element.getAttribute(Attr),\n      getSiblings: () => {\n        let siblings = [],\n          AllChildren = element.parentNode.childNodes;\n        for (let i = 0; i < AllChildren.length; i++)\n          if (AllChildren[i] !== element) siblings.push(AllChildren[i]);\n        return siblings;\n      },\n      Width: () => element.getBoundingClientRect().width,\n      Height: () => element.getBoundingClientRect().height,\n      getRect: () => element.getBoundingClientRect(),\n      setWidth: Width => element.style.width = Width,\n      setHeight: Height => element.style.height = Height,\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      }\n    };\n    else if (is.NodeList(element)) return {\n      On: (eventType, func) => On(eventType, element, func),\n      find: (selector, forceSelectAll) => {\n        let Localelement = queryAll(selector, element);\n        if (Localelement.length > 1 || forceSelectAll === true && !is.Null(Localelement)) return Localelement;\n        if (!is.Null(Localelement)) return Localelement[0];\n        return null;\n      },\n      includes: SelectorNode => {\n        if (!is.Node(SelectorNode)) SelectorNode = query(SelectorNode);\n        for (let index = 0; index < element.length; index++)\n          if (element[index] === SelectorNode) return true;\n        return false;\n      },\n      css: styles => is.Def(styles) ? forEach(element, el => forEach(styles, (prop, key) => el.style[key] = prop)) : console.error('styles unefined'),\n    }\n    return {\n      div: (inner, attr, node) => make_element('div', inner, attr, node),\n      span: (inner, attr, node) => make_element('span', inner, attr, node),\n      label: (inner, attr, node) => make_element('label', inner, attr, node),\n      p: (inner, attr, node) => make_element('p', inner, attr, node),\n      img: (src, alt, inner, attr, node) => make_element('img', inner, attr, node, {\n        src: src,\n        alt: alt\n      }),\n      ul: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ul', list, attr, node)\n      },\n      ol: (items, attr, node) => {\n        let list = ``;\n        if (is.Arr(items)) items.forEach(item => {\n          if (is.String(item)) list += make_element('li', item);\n          else if (is.Object(items)) list += make_element('li', item.inner, item.attr);\n        });\n        return make_element('ol', list, attr, node)\n      },\n      h: (level, inner, attr, node) => make_element('h' + level, inner, attr, node),\n      a: (link, inner, attr, node) => make_element('a', inner, attr, node, {\n        href: link\n      }),\n      script: (code, attr, node) => make_element('script', code, attr, node, {\n        type: 'text/javascript'\n      }),\n      table: (rows, attr, node) => {\n        if (!is.Arr(rows)) return is.String(rows) ? make_element('table', rows, attr, node) : make_element('table', '', attr, node);\n        if (!rows.every(o => is.Object(o))) throw new TypeError('dom.table -> rows : all entries need to be objects');\n        let tableInner = ``;\n        forEach(rows, row => forEach(row, (val, key) => {\n          let row = `<tr>`;\n          if (key === 'cell' || key === 'td' || key === 'data') {\n            if (is.String(val)) row += `<td>${val}</td>`;\n            else if (is.Object(val)) row += make_element('tr', val.inner, val.attr)\n          } else if (key === 'head' || key === 'th') {\n            if (is.String(val)) row += `<th>${val}</th>`;\n            else if (is.Object(val)) row += make_element('th', val.inner, val.attr)\n          }\n          row += '</tr>'\n          tableInner += row;\n        }));\n        return make_element('table', tableInner, attr, node);\n      },\n    }\n  };\n\n  /**\n   * Craft - Crafter.js Core Object containing most methods\n   */\n  var Craft = {\n    ArraytoObject: arr => {\n      let i, NewObject = {};\n      for (i in arr)\n        if (is.Def(arr[i])) NewObject[i] = arr[i];\n      return NewObject;\n    },\n    filterArr: (arr, func) => {\n      let i = -1,\n        x = -1,\n        result = [];\n      while (++i < arr.length)\n        if (func(arr[i], i, arr)) result[++x] = arr[i];\n      return result;\n    },\n    sameArray: (arr1, arr2) => {\n      let i = arr1.length;\n      if (i !== arr2.length) return false;\n      while (i--)\n        if (arr1[i] !== arr2[i]) return false;\n      return true;\n    },\n    CurrentBrowser: {\n      is: browser => _br.join(' ').toLowerCase().includes(browser.toLowerCase()) ? true : false,\n      browser: _br.join(' ')\n    },\n    loader: {\n      pre: 'craft:',\n      CraftImport: obj => {\n        let now = +new Date(),\n          key = obj.key || obj.url,\n          src = Craft.loader.get(key);\n        if (src || src.expire - now > 0) return new Promise(resolve => resolve(src));\n        return new Promise((success, failed) => fetch(obj.url).then(res => res.text().then(data => {\n          obj.data = data;\n          obj.stamp = now;\n          obj.expire = now + ((obj.expire || 4000) * 60 * 60 * 1000);\n          if (obj.cache) localStorage.setItem(Craft.loader.pre + key, JSON.stringify(obj));\n          success(obj);\n        })).catch(err => failed(`Craft.loader: problem fetching import -> ${err}`)));\n      },\n      Import: (...args) => {\n        let obj, promises = [];\n        args.forEach(arg => {\n          obj = {\n            url: arg.css || arg.script,\n            type: arg.css ? 'css' : 'script',\n            exec: arg.execute !== false,\n            cache: arg.cache !== false\n          }\n          if (is.Def(arg.key)) obj.key = arg.key;\n          if (is.Def(arg.defer)) obj.defer = arg.defer;\n          if (is.Def(arg.expire)) obj.expire = arg.expire;\n          arg.test === false ? Craft.loader.remove(obj.url) : promises.push(Craft.loader.CraftImport(obj));\n        });\n        return Promise.all(promises).then(src => src.map(obj => {\n          if (obj.type === 'css') CrafterStyles.innerHTML += '\\n' + obj.data;\n          else if (obj.exec) {\n            let el = dom().script(obj.data, true);\n            el.defer = obj.defer || undefined;\n            head.appendChild(el);\n          }\n        }))\n      },\n      setPrekey: str => Craft.loader.pre = str + ':',\n      get: key => JSON.parse(localStorage.getItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key) || false),\n      remove: key => localStorage.removeItem(key.includes(Craft.loader.pre) ? key : Craft.loader.pre + key),\n      removeAll: expired => {\n        for (let i in localStorage)\n          if (!expired || Craft.loader.get(i).expire <= +new Date()) Craft.loader.remove(i)\n      }\n    },\n    router: {\n      handle: (RouteLink, func) => {\n        if (location.hash === RouteLink || location === RouteLink) func();\n        Craft.router.handlers.push({\n          link: RouteLink,\n          func: func\n        })\n      },\n      handlers: [],\n      links: [],\n      link: (Selector, link, newtab, eventType) => Craft.router.links.push(() => On(is.Def(eventType) ? eventType : 'click', query(Selector), e => newtab ? open(link) : location = link)),\n      open: (link, newtab) => newtab ? open(link) : location = link,\n      setTitle: title => doc.title = title,\n      setView: (viewHostSelector, view) => query(viewHostSelector).innerHTML = view,\n      fetchView: (viewHostSelector, viewURL, cache, id) => {\n        if (is.Null(localStorage.getItem(\"RT_\" + id))) fetch(viewURL).then(res => {\n          res.text().then(txt => {\n            if (cache && is.Def(id) && is.String(id) && is.Null(localStorage.getItem(\"RT_\" + id))) localStorage.setItem((\"RT_\" + id), txt);\n            query(viewHostSelector).innerHTML = txt;\n          });\n        }).catch(msg => console.warn('Could not fetch view -> ' + msg));\n        else if (cache) query(viewHostSelector).innerHTML = localStorage.getItem(\"RT_\" + id)\n      },\n      clearCache: () => {\n        for (let i in localStorage)\n          if (localStorage.key(i).includes(\"RT_\")) localStorage.removeItem(localStorage.key(i));\n      },\n    },\n    Cookies: {\n      get: (key) => key ? decodeURIComponent(doc.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null : null,\n      set: (key, val, expires, path, domain, secure) => {\n        if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key)) return false;\n        let expiry = \"\";\n        if (expires) {\n          if (is.Num(expires)) expiry = expires === Infinity ? \"; expires=Fri, 11 April 9997 23:59:59 UTC\" : \"; max-age=\" + expires;\n          if (is.String(expires)) expiry = \"; expires=\" + expires;\n          if (is.Date(expires)) expiry = \"; expires=\" + expires.toUTCString();\n        }\n        doc.cookie = encodeURIComponent(key) + \"=\" + encodeURIComponent(val) + expiry + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\") + (secure ? \"; secure\" : \"\");\n        return true;\n      },\n      remove: (key, path, domain) => {\n        if (!Craft.Cookies.has(key)) return false;\n        doc.cookie = encodeURIComponent(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (domain ? \"; domain=\" + domain : \"\") + (path ? \"; path=\" + path : \"\");\n        return true;\n      },\n      has: key => key ? (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie) : false,\n      keys: () => {\n        let all = doc.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        all.forEach(c => decodeURIComponent(c));\n        return all;\n      }\n    },\n    after: function (n, func) {\n      if (!is.Func(func)) is.Func(n) ? func = n : console.error(\"after : func is not a function\");\n      n = Number.isFinite(n = +n) ? n : 0;\n      return (...args) => --n < 1 ? func.apply(this, args) : () => null;\n    },\n    debounce: function (wait, func, immediate) {\n      let timeout;\n      return function () {\n        let args = arguments,\n          later = () => {\n            timeout = null;\n            if (!immediate) func.apply(this, args);\n          },\n          callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(this, args);\n      };\n    },\n    throttle: function (wait, func, options) {\n      let context, args, result,\n        timeout = null,\n        previous = 0;\n      if (!options) options = {};\n      let later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      };\n      return function () {\n        let now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        let remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n          }\n          previous = now;\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);\n        return result;\n      };\n    },\n    once: function (func, context) {\n      let res;\n      return function () {\n        if (is.Func(func)) {\n          res = func.apply(context || this, arguments);\n          func = null;\n        }\n        return res;\n      }\n    },\n    css: (el, styles) => (is.Def(styles, el) && is.Node(el)) ? forEach(styles, (prop, key) => el.style[key] = prop) : console.error('invalid args'),\n    hasCapitals: string => {\n      for (let i = 0; i < string.length; i++)\n        if (is.UpperCase(string[i])) return true;\n      return false;\n    },\n    OverrideFunction: (funcName, Func, ContextObject) => {\n      let namespaces = funcName.split(\".\"),\n        func = namespaces.pop();\n      for (let i = 0; i < namespaces.length; i++) ContextObject = ContextObject[namespaces[i]];\n      ContextObject[func] = Func;\n    },\n    concatObjects: (hostobj, ...Objs) => {\n      forEach(hostobj, () => {\n        Objs.forEach(obj => {\n          forEach(obj, (prop, key) => {\n            if (key in hostobj) {\n              if (is.Arr(hostobj[key])) {\n                if (!hostobj[key].includes(prop)) hostobj[key].push(prop);\n              } else if (prop !== hostobj[key]) hostobj[key] = [prop, hostobj[key]];\n            } else hostobj[key] = prop;\n          });\n        });\n      });\n      return hostobj;\n    },\n    mergeObjects: (hostobj, ...Objs) => Object.assign(hostobj, Objs),\n    len: val => {\n      if (is.Object(val)) return Object.keys(val).length;\n      if (is.Map(val) || is.Set(val)) return val.size;\n      try {\n        return val.length;\n      } catch (e) {\n        console.error('could not find length of value');\n      }\n    },\n    type: (...args) => {\n      let types = [];\n      args.forEach(arg => types.push(typeof arg));\n      if (types.length < 2) return types[0];\n      return types;\n    },\n    indexOfDate: (Collection, date) => {\n      for (let i = 0; i < Collection.length; i++)\n        if (+Collection[i] === +date) return i;\n      return -1;\n    },\n    removeArrItem: (Arr, val) => {\n      let index = Arr.IndexOf(val),\n        temp = [],\n        string = false,\n        i = 0;\n      if (is.String(Arr)) {\n        Arr = Array.from(Arr);\n        string = true;\n      }\n      for (; i < Arr.length; i++)\n        if (i !== index) temp.push(Arr[i]);\n      return string ? temp : temp;\n    },\n    omit: (obj, val) => {\n      if (is.Object(obj)) {\n        if (obj !== val) forEach(obj, (prop, key) => {\n          if (val === key || val === prop) delete obj[key];\n        });\n        if (obj.hasOwnProperty(val)) console.error(`couldn't omit ${val} from Object`);\n      } else if (is.Arr(obj) || is.String(obj)) {\n        obj.forEach(i => {\n          if (val === i) obj = Craft.removeArrItem(obj, i);\n        });\n        if (val.IndexOf(i) !== -1) console.error(`couldn't omit ${val} from Array or String`);\n      }\n      return obj;\n    },\n    memoize: function (func, resolver) {\n      if (!is.Func(func) || (resolver && !is.Func(resolver))) throw new TypeError(\"arg provided is not a function\");\n      let cache = new WeakMap;\n      let memoized = function (...args) {\n        let key = resolver ? resolver.apply(this, args) : args[0];\n        if (cache.has(key)) return cache.get(key);\n        let result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      return memoized;\n    },\n    Scope: {},\n    WebComponents: [],\n    ResizeHandlers: new FunctionIterator,\n    Binds: new Map,\n    mouse: {\n      x: 0,\n      y: 0,\n      over: null\n    },\n    nodeExists: (selector, within) => queryAll(selector, (is.Node(within) ? within = within : within = query(within))) !== null,\n    ObjToFormData: obj => {\n      let key, formData = new FormData();\n      for (key in obj) formData.append(key, obj[key]);\n      return formData;\n    },\n    URLfrom: text => URL.createObjectURL(new Blob([text])),\n    OnScroll: (element, func) => is.Func(func) ? On('scroll', element, e => func(e.deltaY < 1 ? false : true, e)) : console.error('second param needs to be a function'),\n    OnResize: func => is.Func(func) ? Craft.ResizeHandlers.add(func) : console.error(\"Craft.OnResize -> func is not a function\"),\n    OnScrolledTo: (Scroll, ifFunc, elseFunc) => On('scroll', e => {\n      if (pageYOffset >= Scroll) ifFunc(e);\n      else if (is.Def(elseFunc)) elseFunc(e);\n    }),\n    WhenScrolledTo: Scroll => new Promise((resolve, reject) => {\n      let scrollEvent = On('scroll', e => {\n        if (pageYOffset >= Scroll || pageYOffset <= Scroll) {\n          scrollEvent.Off();\n          resolve(e);\n        }\n      })\n    }),\n    /**\n     * function that returns a promise when the DOM and WebComponents are finished loading\n     * @namespace Craft\n     */\n    WhenReady: Scope => new Promise((resolve, reject) => {\n      let waitIncase = Craft.CurrentBrowser.is(\"Firefox\") || Craft.CurrentBrowser.is(\"msie\");\n      Scope = Scope || Craft.Scope;\n      if (Ready) waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n      else {\n        let ReadyYet = setInterval(() => {\n          if (Ready) {\n            waitIncase ? setTimeout(() => resolve(Scope), 500) : resolve(Scope);\n            clearInterval(ReadyYet);\n          }\n        }, 20);\n        setTimeout(() => {\n          clearInterval(ReadyYet);\n          if (!Ready) reject(\"Things didn't load correctly/intime -> load failed\");\n        }, 4500)\n      }\n    }),\n    poll: (test, interval, timeout, success, fail) => {\n      return (() => {\n        if (is.Func(timeout)) {\n          if (is.Func(success)) fail = success;\n          success = timeout;\n          timeout = undefined;\n        }\n        let Interval = setInterval(() => {\n          if ((is.Bool(test) && test === true) || (is.Func(test) && test() === true)) {\n            success();\n            clearInterval(Interval);\n          }\n        }, interval || 20);\n        if (is.Num(timeout)) setTimeout(() => {\n          clearInterval(Interval);\n          if ((is.Bool(test) && test === false) || (is.Func(test) && test() === false)) fail();\n        }, timeout);\n      })();\n    },\n    /**\n     * Usefull method for validating passwords\n     */\n    strongPassword: (pass, length, caps, number, ...includeChars) => {\n      if (pass.length <= length) return false;\n      if (caps === true && Craft.hasCapitals(pass) === false) return false;\n      if (number === true && /\\d/g.test(pass) === false) return false;\n      if (includeChars.length !== 0) {\n        let hasChars = true;\n        includeChars.forEach(ch => {\n          if (!pass.includes(ch)) hasChars = false;\n        });\n        if (!hasChars) return false\n      }\n      return true;\n    },\n    /** method for generating random alphanumeric strings*/\n    randomString: () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),\n    GenUID: () => Craft.randomString() + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + '-' + Craft.randomString() + Craft.randomString() + Craft.randomString(),\n    createWebComponent: webcomponent => {\n      if (is.String) webcomponent = JSON.parse(webcomponent);\n      CrafterStyles.innerHTML += webcomponent.css;\n      let wcJS = dom().script('', {\n        src: Craft.URLfrom(webcomponent.js),\n        webcomponent: webcomponent.name\n      }, true);\n      wcJS.onload = e => Craft.WebComponents.push(webcomponent.name);\n      head.appendChild(wcJS);\n    },\n    /**\n     * method for creating custom elements\n     * configuring their lifecycle's and inheritance\n     */\n    newComponent: function (tag, config) {\n      if (is.Undef(config)) console.error(\"Invalid Component Configuration\");\n      else {\n        let element = Object.create(HTMLElement.prototype),\n          settings = {}\n        forEach(config, (prop, key) => {\n          if (key === 'created') element.createdCallback = prop;\n          else if (key === 'inserted') element.attachedCallback = prop;\n          else if (key === 'destroyed') element.detachedCallback = prop;\n          else if (key === 'attr') element.attributeChangedCallback = prop;\n          else if (key === 'extends') settings.extends = prop;\n          else if (is.Func(prop)) element[key] = prop;\n          else if (key !== 'extends' && !is.Func(prop)) element[key] = prop\n        });\n        settings['prototype'] = element;\n        doc.registerElement(tag, settings)\n      }\n    },\n    /** creates a new bound variable , part of Crafter.js's Data Binding System */\n    newBind: (key, val, handle) => {\n      is.Func(handle) ? Craft.Binds.set(key, new ReactiveVariable(val, handle)) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.Func(handle) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'));\n      });\n    },\n    /** sets the value of a bound variable */\n    setBind: (key, val) => {\n      is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(key).set(val) : Craft.Binds.set(key, val);\n      queryEach('[view-bind]', el => {\n        if (Craft.Binds.has(el.getAttribute('view-bind'))) el.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(el.getAttribute('view-bind')).val : Craft.Binds.get(el.getAttribute('view-bind'))\n      });\n    },\n  };\n\n  Craft.loader.removeAll(true);\n\n  On('animationstart', doc, e => {\n    if (e.animationName === 'NodeInserted' && is.Node(e.target)) {\n      if (e.target.hasAttribute('[view-bind]') && Craft.Binds.has(e.target.getAttribute('view-bind'))) e.target.innerHTML = is.ReactiveVariable(Craft.Binds.get(key)) ? Craft.Binds.get(e.target.getAttribute('view-bind')).val : Craft.Binds.get(e.target.getAttribute('view-bind'));\n    }\n  });\n\n  root.onresize = Craft.throttle(450, e => Craft.ResizeHandlers.runEach(e));\n  root.onmousemove = e => {\n    Craft.mouse.x = e.clientX;\n    Craft.mouse.y = e.clientY;\n    Craft.mouse.over = e.target;\n  }\n  root.onblur = e => Craft.tabActive = false;\n  root.onfocus = e => Craft.tabActive = true;\n\n  Craft.newComponent('fetch-webcomponent', {\n    created: function () {\n      if (this.hasAttribute('src')) {\n        let wc = null;\n        if (this.hasAttribute('cache-component')) {\n          wc = localStorage.getItem(this.getAttribute('src'));\n          if (wc !== null) Craft.createWebComponent(wc);\n        }\n        if (wc === null) fetch(this.getAttribute('src')).then(res => res.json().then(webcomponent => {\n          CrafterStyles.innerHTML += webcomponent.css;\n          let wcJS = dom().script('', {\n            src: Craft.URLfrom(webcomponent.js),\n            webcomponent: webcomponent.name\n          }, true);\n          wcJS.onload = e => {\n            Craft.WebComponents.push(webcomponent.name);\n            wcJS = null;\n            webcomponent = null;\n          }\n          head.appendChild(wcJS);\n          if (this.getAttribute('cache-component') === 'true') localStorage.setItem(this.getAttribute('src'), JSON.stringify(webcomponent));\n        })).catch(err => console.error(err + ': could not load webcomponent'))\n      }\n    }\n  });\n\n  Once('DOMContentLoaded', () => {\n    queryEach('[link]', el => On('click', el, e => el.hasAttribute('newtab') ? open(el.getAttribute('link')) : Craft.router.open(el.getAttribute('link'))));\n    Craft.router.links.forEach(link => link());\n    if (Craft.WebComponents.length === queryAll('fetch-webcomponent').length) Ready = true;\n    else Craft.poll(() => Craft.WebComponents.length === queryAll('fetch-webcomponent').length, 35, 2000, () => Ready = true, () => {\n      console.log('loading is taking longer than usual :(');\n      Ready = true\n    })\n  });\n\n\n  On('hashchange', e => Craft.router.handlers.forEach(handler => (location.hash === handler.link || location === handler.link) ? handler.func() : null));\n\n  root.is = is;\n  root.dom = dom;\n  root.Craft = Craft;\n  root.On = On;\n  root.Once = Once;\n  root.forEach = forEach;\n  root.QueryOrNodetoNodeArray = QueryOrNodetoNodeArray;\n  root.make_element = make_element;\n  root.FunctionIterator = FunctionIterator;\n  root.CraftSocket = CraftSocket;\n  root.EventHandler = EventHandler;\n  root.ReactiveVariable = ReactiveVariable;\n  root.query = query;\n  root.queryAll = queryAll;\n  root.queryEach = queryEach;\n})(document, self);\n"
    },
    "params": [
      {
        "title": "param",
        "description": "pass either a CSS Selector string , Node/NodeList or Array of Nodes",
        "lineNumber": 2,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Node"
            },
            {
              "type": "NameExpression",
              "name": "NodeList"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        },
        "name": "val"
      }
    ],
    "name": "QueryOrNodetoNodeArray",
    "kind": "class",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "QueryOrNodetoNodeArray"
    ]
  }
]