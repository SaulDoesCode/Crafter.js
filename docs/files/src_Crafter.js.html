<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/Crafter.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Cookies.html">Cookies</a></li>
                                <li><a href="../classes/Craft.html">Craft</a></li>
                                <li><a href="../classes/dom.html">dom</a></li>
                                <li><a href="../classes/EventHandler.html">EventHandler</a></li>
                                <li><a href="../classes/is.html">is</a></li>
                                <li><a href="../classes/router.html">router</a></li>
                                <li><a href="../classes/Socket.html">Socket</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/Crafter.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 *  @version 0.0.9
 *  @overview Crafter.js , minimalist front-end library
 *  @author Saul van der Walt - https://github.com/SaulDoesCode/
 *  @license MIT  Licence (c) Copyright 2016 Saul van der Walt
 */
(function (doc, root) {
    &#x27;use strict&#x27;;
    let Ready = false,
        ua = navigator.userAgent,
        tem, Br = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);

    if (Br &amp;&amp; (tem = ua.match(/version\/([\.\d]+)/i)) !== null) Br[2] = tem[1];
    Br = (Br ? [Br[1], Br[2]] : [navigator.appName, navigator.appVersion, &#x27;-?&#x27;]).join(&#x27; &#x27;);

    const newMap = () =&gt; new Map,
        newSet = () =&gt; new Set;

    /**
     * Slices any arraylike object.
     * @method slice
     * @for Craft
     * @param {arraylike} ctx - object to slice
     * @param {int|String} i - value to slice defaults to 0
     */
    const slice = (ctx, i) =&gt; ctx.slice ? ctx.slice(i || 0) : Array.prototype.slice.call(ctx, i || 0);
    /**
     * curry takes a function as a parameter and returns another function until all the arguments of the initializer function has been provided.
     * @method curry
     * @for Craft
     * @param {Function} fn - function to curry
     * @param {Class|Function|Object} ctx - context to bind the function to
     * @return {Function|*}
     */
    function curry(fn, ctx) {
        const arity = fn.length;

        function curried() {
            const args = slice(arguments);
            return args.length &lt; arity ? (...more) =&gt; curried.apply(null, args.concat(more)) : fn.apply(ctx || this, args);
        }
        return curried;
    }

    // tests arguments with Array.prototype.every;
    const ta = test =&gt; (...args) =&gt; args.length &gt;= 1 &amp;&amp; args.every(test);

    /**
     *  get the last item in an array or arraylike collection
     *  @method last
     *  @for Craft
     *  @param {Array|Arraylike} arr - array or arraylike collection
     *  @return {*} last item in collection
     */
    const last = arr =&gt; arr[arr.length - 1];
    /**
     *  get the first item in an array or arraylike collection
     *  @method first
     *  @for Craft
     *  @param {Array|Arraylike} arr - array or arraylike collection
     *  @return {*} first item in collection
     */
    const first = arr =&gt; arr[0];

    const removeFrom = (arr, i) =&gt; {
            const index = arr.indexOf(i);
            return index &gt; -1 ? arr.splice(index, 1) : arr;
        }
        /**
         * Convert Arraylike variables to Array synonym for Array.from
         * @method toArr
         * @pram {Arraylike} val - arraylike value to convert to array
         * @return {Array}
         */
    const toArr = arr =&gt; Array.isArray(arr) ? arr : typeof arr.length != &quot;undefined&quot; ? Array.from(arr) : [arr];

    const sI = &#x27;InputSync&#x27;,
        DestructionEvent = new Event(&#x27;destroy&#x27;),
        possibleText = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;,
        undef = void 0,
        defineprop = Object.defineProperty,
        getpropdescriptor = Object.getOwnPropertyDescriptor,
        def = ta(o =&gt; typeof o !== &#x27;undefined&#x27;),
        nil = ta(o =&gt; o === null),
        isFunc = o =&gt; typeof o === &#x27;function&#x27;,
        isStr = o =&gt; typeof o === &#x27;string&#x27;,
        isObj = o =&gt; toString.call(o) === &#x27;[object Object]&#x27;,
        isEl = o =&gt; o.toString().includes(&#x27;HTML&#x27;),
        isArr = Array.isArray,
        ready = () =&gt; Ready || doc.readyState == &#x27;complete&#x27;,
        promise = func =&gt; new Promise(func),
        noop = () =&gt; {},
        head = doc.head,
        RegExps = {
            email: /^((([a-z]|\d|[!#\$%&amp;&#x27;\*\+\-\/=\?\^_&#x60;{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&amp;&#x27;\*\+\-\/=\?\^_&#x60;{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,
            timeString: /^(2[0-3]|[01]?[0-9]):([0-5]?[0-9]):([0-5]?[0-9])$/,
            dateString: /^(1[0-2]|0?[1-9])\/(3[01]|[12][0-9]|0?[1-9])\/(?:[0-9]{2})?[0-9]{2}$/,
            hexadecimal: /^[0-9a-fA-F]+$/,
            hexColor: /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/
        },
        desc = (value, write, enumerable) =&gt; ({
            value,
            write: is.Bool(write) ? write : false,
            enumerable: is.Bool(enumerable) ? enumerable : false
        });


    /**
     * creates a document fragment from a string (document, fragment, from, String} - dffstr
     * @method dffstr
     * @for Craft
     * @param {String} html - text to convert to html
     */
    function dffstr(html) {
        return doc.createRange().createContextualFragment(html || &#x27;&#x27;);
    }

    // get the string form of any object
    // then compare it to a given string
    function type(obj, str) {
        return toString.call(obj) === str;
    }


    /**
     * Checks whether a collection or object contains a certain value.
     * @method has
     * @for Craft
     * @param {object|arraylike|set|map} host - collection or object to search in
     * @param {*} value - the value to look for
     * @param {Boolean} or - some or every, some by default
     */
    function has(host, value, or) {
        if (is.Arraylike(host)) return slice(host)[(!or ? &#x27;every&#x27; : &#x27;some&#x27;)](host.includes.bind(host));
        if (isObj(host)) return Object.prototype.hasOwnProperty.call(host, value);
        if (is.Set(host) || is.Map(host)) return host.has(value);
    }

    /**
     * maps through arraylike and object values;
     * @method map
     * @for Craft
     * @param {Arraylike|Object} collection
     * @param {Function} func - mapping function
     */
    const map = curry((collection, func) =&gt; {
        if (is.Arraylike(collection)) return Array.prototype.map.call(collection, func);
        Object.keys(collection).map(key =&gt; {
            const val = collection.isObservable ? collection.get(key) : collection[key];
            const mappee = func(val, key, collection);
            if (val != undef &amp;&amp; val != mappee) collection.isObservable ? collection.set(key, mappee) : collection[key] = mappee;
        });
        return collection;
    });


    /**
     * converts a number or string value to an integer
     * @method toInt
     * @for Craft
     * @param {Number|String} num - number to convert
     * @return {Number} integer number
     */
    function toInt(num) {
        if (isStr(num)) num = Number(num);
        if (isNaN(num)) return 0;
        if (num === 0 || !isFinite(num)) return num;
        return (num &gt; 0 ? 1 : -1) * Math.floor(Math.abs(num));
    }

    /**
     * Splits a string at dots &quot;.&quot;.
     * @method cutdot
     * @for Craft
     * @param {String} str - string to split at the dots
     */
    const cutdot = str =&gt; str.split(&#x27;.&#x27;);
    /**
     * joins a string array with dots &quot;.&quot;
     * @method joindot
     * @for Craft
     * @param {Array|Arraylike} arr - array to join with dots
     */
    const joindot = arr =&gt; slice(arr).join(&#x27;.&#x27;);


    /**
     * is - Type Testing / Assertion
     * @class is
     */
    const is = {
        /**
         * Test if something is a Boolean type
         * @method Bool
         * @for is
         * @param {...*} args - value/values to test
         */
        Bool: ta(o =&gt; typeof o === &#x27;Boolean&#x27;),
        /**
         * Test if something is a String
         * @method Str
         * @for is
         * @param {*} val - value to test
         */
        Str: isStr,
        /**
         * Test if values are strings
         * @method Str
         * @for is
         * @param {...*} args - value/values to test
         */
        String: ta(isStr),
        /**
         * Test if something is an Array
         * @method Arr
         * @for is
         * @param {...*} args - value/values to test
         */
        Arr: ta(isArr),
        /**
         * Array.isArray alias for convenience and performance when only one argument is present
         * @method Array
         * @for is
         * @param {*} val - value to test
         */
        Array: isArr,
        /**
         * Test if a value or multiple values are Array-Like
         * @method Arraylike
         * @for is
         * @param {...*} args - value/values to test
         */
        Arraylike: ta(o =&gt; {
            try {
                return def(o.length);
            } catch (e) {}
            return false;
        }),
        /**
         * Determine whether a value is undefined
         * @method Undef
         * @for is
         * @param {...*} args - value/values to test
         */
        Undef() {
            return !def.apply(this, arguments);
        },
        /**
         * Determine whether a value is in fact defined
         * @method Def
         * @for is
         * @param {...*} args - value/values to test
         */
        Def: def,
        /**
         * Determine whether a value is null
         * @method Null
         * @for is
         * @param {...*} args - value/values to test
         */
        Null: ta(o =&gt; o === null),
        /**
         * Determine whether a value is a DOM Node
         * @method Node
         * @for is
         * @param {...*} args - value/values to test
         */
        Node: ta(o =&gt; o instanceof Node),
        /**
         * Test an element&#x27;s tagname
         * @method Tag
         * @for is
         * @param {Node} element - node to test
         * @param {String} tag - tag to test node for
         */
        Tag: (element, tag) =&gt; isEl(element) ? element.tagName === tag.toUpperCase() : false,
        /**
         * Determine whether a value is a DOM NodeList or Collection of Nodes
         * @method NodeList
         * @for is
         * @param {...*} args - value/values to test
         */
        NodeList: ta(nl =&gt; nl instanceof NodeList || is.Arraylike(nl) &amp;&amp; !is.empty(nl) ? Array.prototype.every.call(nl, n =&gt; n instanceof Node) : false),
        /**
         * Determine if a value is a Number
         * @method Num
         * @for is
         * @param {...*} args - value/values to test
         */
        Num: ta(o =&gt; !isNaN(Number(o))),
        /**
         * Determine if a value is an Object
         * @method Object
         * @for is
         * @param {...*} args - value/values to test
         */
        Object: ta(isObj),
        /**
         * Determine if a value is an Object
         * @method Obj
         * @for is
         * @param {...*} args - value/values to test
         */
        Obj: isObj,
        /**
         * Determine if a sring is JSON
         * @method Json
         * @for is
         * @param {...*} args - value/values to test
         */
        Json: ta(str =&gt; {
            try {
                JSON.parse(str);
                return true;
            } catch (e) {}
            return false;
        }),
        /**
         * Determine if a value is a HTMLElement
         * @method Element
         * @for is
         * @param {...*} args - value/values to test
         */
        Element: ta(isEl),
        /**
         * Determine if a value is a File Object
         * @method File
         * @for is
         * @param {...*} args - value/values to test
         */
        File: ta(o =&gt; type(o, &#x27;[object File]&#x27;)),
        /**
         * Determine if a value is of a FormData type
         * @method FormData
         * @for is
         * @param {...*} args - value/values to test
         */
        FormData: ta(o =&gt; type(o, &#x27;[object FormData]&#x27;)),
        /**
         * Determine if a value is a Map
         * @method Map
         * @for is
         * @param {...*} args - value/values to test
         */
        Map: ta(o =&gt; type(o, &#x27;[object Map]&#x27;)),
        /**
         * Determine if a value is a function
         * @method Func
         * @for is
         * @param {...*} args - value/values to test
         */
        Func: ta(isFunc),
        /**
         * Determine if a variable/s are true
         * @method True
         * @for is
         * @param {...*} args - value/values to test
         */
        True: ta(o =&gt; o === true),
        /**
         * Determine if a variable/s are false
         * @method False
         * @for is
         * @param {...*} args - value/values to test
         */
        False: ta(o =&gt; !o),
        /**
         * Determine if a value is of Blob type
         * @method Blob
         * @for is
         * @param {...*} args - value/values to test
         */
        Blob: ta(o =&gt; type(o, &#x27;[object Blob]&#x27;)),
        /**
         * Determine if a value is a Regular Expression
         * @method RegExp
         * @for is
         * @param {...*} args - value/values to test
         */
        RegExp: ta(o =&gt; type(o, &#x27;[object RegExp]&#x27;)),
        /**
         * Determine if a value is a Date type
         * @method Date
         * @for is
         * @param {...*} args - value/values to test
         */
        Date: ta(o =&gt; type(o, &#x27;[object Date]&#x27;)),
        /**
         * Determine if a value is a Set.
         * @method Set
         * @for is
         * @param {...*} args - value/values to test
         */
        Set: ta(o =&gt; type(o, &#x27;[object Set]&#x27;)),
        /**
         * Determine if a value is of type Arguments
         * @method Args
         * @for is
         * @param {*} val - value/values to test
         */
        Args: val =&gt; !nil(val) &amp;&amp; type(val, &#x27;[object Arguments]&#x27;),
        /**
         * Determine if a value is a Symbol
         * @method Symbol
         * @for is
         * @param {...*} args - value/values to test
         */
        Symbol: ta(obj =&gt; type(obj, &#x27;[object Symbol]&#x27;)),
        /**
         * tests if a value is a single character
         * @method char
         * @for is
         * @param {...String} values to test
         */
        char: ta(val =&gt; isStr(val) &amp;&amp; val.length == 1),
        /**
         * tests if a value is a space character
         * @method space
         * @for is
         * @param {...String} values to test
         */
        space: ta(val =&gt; is.char(val) &amp;&amp; (val.charCodeAt(0) &gt; 8 &amp;&amp; val.charCodeAt(0) &lt; 14) || val.charCodeAt(0) === 32),
        /**
         * Determine if a String is UPPERCASE
         * @method Uppercase
         * @for is
         * @param {String} char - value to test
         */
        Uppercase: str =&gt; isStr(str) &amp;&amp; !is.Num(str) &amp;&amp; str === str.toUpperCase(),
        /**
         * Determine if a String is LOWERCASE
         * @method Lowercase
         * @for is
         * @param {String} char - value to test
         */
        Lowercase: str =&gt; isStr(str) &amp;&amp; str === str.toLowerCase(),
        /**
         * Determine if a String contains only characters and numbers (alphanumeric)
         * @method Alphanumeric
         * @for is
         * @param {String} str - value to test
         */
        Alphanumeric: str =&gt; /^[0-9a-zA-Z]+$/.test(str),
        /**
         * Determines whether a String is a valid email
         * @method email
         * @for is
         * @param {String} email - value to test
         */
        email: email =&gt; RegExps.email.test(email),
        /**
         * Determines whether a String is a URL
         * @method URL
         * @for is
         * @param {String} url - value to test
         */
        URL(url) {
            try {
                new URL(url);
                return true;
            } catch (e) {}
            return false;
        },
        /**
         * Determines whether a String is a HEX-COLOR (#fff123)
         * @method HexColor
         * @for is
         * @param {String} HexColor - value to test
         */
        HexColor: hexColor =&gt; RegExps.hexColor.test(hexColor),
        /**
         * Determines whether a String is hexadecimal
         * @method hexadecimal
         * @for is
         * @param {String} hexadecimal - value to test
         */
        hexadecimal: hexadecimal =&gt; RegExps.hexadecimal.test(hexadecimal),
        /**
         * checks wether a date is today
         * @method today
         * @for is
         * @param {Date} obj - Date to test
         */
        today: obj =&gt; is.Date(obj) &amp;&amp; obj.toDateString() === new Date().toDateString(),
        /**
         * checks wether a date is yesterday
         * @method yesterday
         * @for is
         * @param {Date} obj - Date to test
         */
        yesterday(obj) {
            if (is.Date(obj)) {
                let now = new Date();
                return obj.toDateString() === new Date(now.setDate(now.getDate() - 1)).toDateString();
            }
            return false;
        },
        /**
         * checks wether a date is tommorow
         * @method tomorrow
         * @for is
         * @param {Date} obj - Date to test
         */
        tomorrow(obj) {
            if (is.Date(obj)) {
                let now = new Date();
                return is.Date(obj) &amp;&amp; obj.toDateString() === new Date(now.setDate(now.getDate() + 1)).toDateString();
            }
            return false;
        },
        /**
         * Determines if a date is in the past
         * @method past
         * @for is
         * @param {String|Date} obj - Date to test
         */
        past(obj) {
            try {
                if (!is.Date(obj)) obj = isStr(obj) ? new Date(is.Num(obj) ? Number(obj) : obj) : new Date(obj);
            } catch (e) {}
            return is.Date(obj) &amp;&amp; obj.getTime() &lt; new Date().getTime();
        },
        /**
         * Determines if a date is in the future
         * @method future
         * @for is
         * @param {String|Date} obj - Date to test
         */
        future: obj =&gt; !is.past(obj),
        /**
         * Determines whether a String is a timeString
         * @method time
         * @for is
         * @param {String} time - value to test
         */
        time: time =&gt; RegExps.timeString.test(time),
        /**
         * Determines whether a String is a dateString
         * @method dateString
         * @for is
         * @param {String} dateString - value to test
         */
        dateString: dateString =&gt; RegExps.dateString.test(dateString),
        /**
         * Determines whether a Number is between a maximum and a minimum
         * @method between
         * @for is
         * @param {Number} val - number value to test
         * @param {Number} max - maximum to compare the value with
         * @param {Number} min - minimum to compare the value with
         * @return {Boolean} wether or not the value is between the max and min
         */
        between: curry((val, max, min) =&gt; (val &lt;= max &amp;&amp; val &gt;= min)),
        /**
         * checks if a number is an integer
         * @method int
         * @for is
         * @param {*} val - value to test
         */
        int: val =&gt; is.Num(val) &amp;&amp; val % 1 === 0,
        /**
         * checks if a number is an even number
         * @method even
         * @for is
         * @param {*} val - value to test
         */
        even: val =&gt; is.Num(val) &amp;&amp; val % 2 === 0,
        /**
         * checks if a number is an odd number
         * @method odd
         * @for is
         * @param {*} val - value to test
         */
        odd: val =&gt; is.Num(val) &amp;&amp; val % 2 !== 0,
        /**
         * @method positive
         * checks if a number is positive
         * @for is
         * @param {*} val - value to test
         */
        positive: val =&gt; is.Num(val) &amp;&amp; val &gt; 0,
        /**
         * checks if a number is positive
         * @method negative
         * @for is
         * @param {*} val - value to test
         */
        negative: val =&gt; is.Num(val) &amp;&amp; val &lt; 0,
        /**
         * tests that all parameters following the first are not the same as the first
         * @method neither
         * @for is
         * @param {*} value - inital value to compare all other params with
         * @param {...*} arguments to compare with value
         */
        neither(value) {
            return slice(arguments, 1).every(val =&gt; value !== val);
        },
        /**
         * Determines if two variables are equal
         * @method eq
         * @for is
         * @param a - first value to compare
         * @param b - second value to compare
         */
        eq: curry((a, b) =&gt; a === b),
        /**
         * Returns the a || b
         * @method or
         * @for is
         * @param a - first value to compare
         * @param b - second value to compare
         */
        or: curry((a, b) =&gt; a || b),
        /**
         * Determines if a number is LOWER than another
         * @method lt
         * @for is
         * @param {Number} val - value to test
         * @param {Number} other - num to test with value
         */
        lt: curry((val, other) =&gt; val &lt; other),
        /**
         * Determines if a number is LOWER than or equal to another
         * @method lte
         * @for is
         * @param {Number} val - value to test
         * @param {Number} other - num to test with value
         */
        lte: curry((val, other) =&gt; val &lt;= other),
        /**
         * Determines if a number is BIGGER than another
         * @method bt
         * @for is
         * @param {Number} val - value to test
         * @param {Number} other - num to test with value
         */
        bt: curry((val, other) =&gt; val &gt; other),
        /**
         * Determines if a number is BIGGER than or equal to another
         * @method bte
         * @for is
         * @param {Number} val - value to test
         * @param {Number} other - num to test with value
         */
        bte: curry((val, other) =&gt; val &gt;= other),
        /**
         * Determines if a given collection or string is empty
         * @method empty
         * @for is
         * @param {Object|Array|String} val - value to test if empty
         */
        empty: ta(val =&gt; {
            try {
                return !(isObj(val) ? Object.keys(val).length : is.Map(val) || is.Set(val) ? val.size : val.length) || val === &#x27;&#x27;;
            } catch (e) {}
            return false;
        }),
        /**
         * Tests if something is a Native JavaScript feature
         * @method Native
         * @for is
         * @param {*} val - value to test
         */
        Native(val) {
            let type = typeof val;
            return isFunc(val) ? RegExp(&#x27;^&#x27; + String(Object.prototype.toString).replace(/[.*+?^${}()|[\]\/\\]/g, &#x27;\\$&amp;&#x27;).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, &#x27;$1.*?&#x27;) + &#x27;$&#x27;).test(Function.prototype.toString.call(val)) : (val &amp;&amp; type == &#x27;object&#x27; &amp;&amp; /^\[object .+?Constructor\]$/.test(val.toString)) || false;
        },
        /**
         * Tests where a dom element is an input of some sort
         * @method Input
         * @for is
         * @param {Element|Node} - element to test
         */
        Input: element =&gt; isEl(element) &amp;&amp; [&#x27;INPUT&#x27;, &#x27;TEXTAREA&#x27;].some(i =&gt; element.tagName.includes(i))
    };

    /**
     * Easy way to loop through Collections, Objects and Numbers
     * @method forEach
     * @for Craft
     * @param {Array|Object|NodeList|Number|Arguments} iterable - any collection that is either an Object or has a .length value
     * @param {Function} func - function called on each iteration -&gt; &quot;function( value , indexOrKey ) {...}&quot;
     */
    function forEach(iterable, func) {
        if (isFunc(func)) {
            let i = 0;
            if (is.Arraylike(iterable) &amp;&amp; !localStorage)
                for (; i &lt; iterable.length; i++) func(iterable[i], i, iterable);
            else if (is.int(iterable) &amp;&amp; !isStr(iterable))
                while (iterable != i) func(i++);
            else
                for (i in iterable)
                    if (iterable.hasOwnProperty(i)) func(iterable[i], i, iterable);
        }
    }
    /**
     * Checks an array&#x27;s length if the array contains only a single item it is returned.
     * @method deglove
     * @for Craft
     * @param {array|arraylike) arr - collection to deglove
     * @return (array|*)
     */
    const deglove = arr =&gt; is.Arraylike(arr) &amp;&amp; arr.length == 1 ? arr[0] : arr;
    /**
     * Method to merge the properties of multiple objects , it can handle getters or setters without breaking them
     * @method concatObjects
     * @for Craft
     * @param {Object} host - main object to merge with all subsequent objects
     * @param {...Object} objs - other objects to be merged with host object
     * @return {Object} resulting object after merges
     */
    function concatObjects(host) {
        slice(arguments, 1).map(obj =&gt; {
            for (let key in obj) defineprop(host, key, getpropdescriptor(obj, key));
        });
        return host;
    }

    function listener() {
        const container = newMap(),
            actions = {
                delete(type, func) {
                    if (actions.has(type, func)) {
                        const handlers = container.get(type);
                        if (!handlers.size) container.delete(type);
                        if (handlers.has(func)) handlers.delete(func);
                    }
                },
                set(type, func, once) {
                    if (isFunc(func)) {
                        if (!container.has(type)) container.set(type, newSet());
                        if (once === true) func.__isOnce = true;
                        container.get(type).add(func);
                    }
                },
                get(type) {
                    return container.get(type);
                },
                has(type, func) {
                    return container.size &gt; 0 &amp;&amp; container.has(type) &amp;&amp; container.get(type).has(func);
                },
                loop(type, fn) {
                    if (container.size &gt; 0 &amp;&amp; container.has(type)) {
                        const handlers = container.get(type);
                        handlers.forEach(handler =&gt; {
                            fn(handler);
                            if (handler.__isOnce === true) handlers.delete(handler);
                        });
                    }

                },
                makeHandle(type, func) {
                    if (!isFunc(func)) throw new TypeError(&#x27;eventsys : listener needs a function&#x27;);
                    return {
                        on() {
                            isArr(type) ? type.map(t =&gt; {
                                actions.set(t, func);
                            }) : actions.set(type, func);
                            return this;
                        },
                        once() {
                            isArr(type) ? type.map(t =&gt; {
                                actions.set(t, func, true);
                            }) : actions.set(type, func, true);
                            return this;
                        },
                        off() {
                            isArr(type) ? type.map(t =&gt; {
                                actions.delete(t, func);
                            }) : actions.delete(type, func);
                            return this;
                        }
                    };
                }
            };
        return actions;
    }

    /**
     * Adds an Event System to Arbitrary Objects and Classes.
     * @method eventsys
     * @for Craft
     * @param {Object|Function|Class} obj - object to convert
     */
    function eventsys(obj) {
        if (!obj) obj = {};
        const listeners = listener();
        let stop = false;
        obj.on = (type, func) =&gt; listeners.makeHandle(type, func).on();
        obj.once = (type, func) =&gt; listeners.makeHandle(type, func).once();
        obj.off = (type, func) =&gt; listeners.makeHandle(type, func).off();
        obj.emit = function (type) {
            if (!stop &amp;&amp; isStr(type)) {
                const args = slice(arguments, 1);
                listeners.loop(type, handle =&gt; {
                    handle.apply(obj, args);
                });
            } else throw new TypeError(&#x27;eventsys : you cannot emit that! &#x27; + type);
        }
        obj.stopall = state =&gt; stop = isBool(state) ? state : true;
        obj.defineHandle = (name, type) =&gt; {
            if (!type) type = name;
            obj[name] = (fn, useOnce) =&gt; obj[useOnce ? &#x27;once&#x27; : &#x27;on&#x27;](type, fn);
        }
        return obj;
    }
    /**
     * Creates observables.
     * @method observable
     * @for Craft
     * @param {Object|Function|Class} obj - object to convert
     */
    function observable(obj) {
        if (!obj) obj = {};
        obj = eventsys(obj);
        const listeners = listener();
        defineprop(obj, &#x27;isObservable&#x27;, desc(true));
        [&#x27;$get&#x27;, &#x27;$set&#x27;].map(prop =&gt; {
            const accessor = prop == &#x27;$get&#x27; ? &#x27;Get&#x27; : &#x27;Set&#x27;;
            defineprop(obj, prop, desc((prop, func) =&gt; {
                if (isFunc(prop)) {
                    func = prop;
                    prop = &#x27;*&#x27;;
                }
                if (!isFunc(func)) throw new Error(&#x27;.&#x27; + prop + &#x27; no function&#x27;);
                func.prop = isStr(prop) ? prop : &#x27;*&#x27;;
                return listeners.makeHandle(accessor, func).on();
            }));
        });
        defineprop(obj, &#x27;get&#x27;, desc(key =&gt; {
            if (key != &#x27;get&#x27; &amp;&amp; key != &#x27;set&#x27;) {
                let val;
                listeners.loop(&#x27;Get&#x27;, ln =&gt; {
                    if (ln.prop === &#x27;*&#x27; || ln.prop === key) val = ln(key, obj);
                });
                return val != undef ? val : obj[key];
            } else return obj[key];
        }));
        defineprop(obj, &#x27;set&#x27;, desc(curry((key, value) =&gt; {
            let val;
            listeners.loop(&#x27;Set&#x27;, ln =&gt; {
                if (ln.prop === &#x27;*&#x27; || ln.prop === key) ln(key, value, obj, Object.hasOwnProperty(obj, key));
            });
            val = val != undef ? val : value;
            if (isObj(val) &amp;&amp; !val.isObservable) val = observable(val);
            obj[key] = val;
            obj.emit(&#x27;$uberset:&#x27; + key, val);
        })));
        for (let key in obj)
            if (isObj(obj[key]) &amp;&amp; !obj[key].isObservable) obj[key] = observable(obj[key]);
        if (typeof Proxy != &#x27;undefined&#x27;) return new Proxy(obj, {
            get(target, key) {
                if (key != &#x27;get&#x27; &amp;&amp; key != &#x27;set&#x27;) {
                    let val;
                    listeners.loop(&#x27;Get&#x27;, ln =&gt; {
                        if (ln.prop === &#x27;*&#x27; || ln.prop === key) val = ln(key, target);
                    });
                    return val != undef ? val : Reflect.get(target, key);
                } else return Reflect.get(target, key);
            },
            set(target, key, value) {
                let val, onetime = false;
                listeners.loop(&#x27;Set&#x27;, ln =&gt; {
                    if (ln.prop === &#x27;*&#x27; || ln.prop === key) {
                        if (onetime) {
                            value = val;
                            onetime = false;
                        } else onetime = true;
                        val = ln(key, value, target, !Reflect.has(target, key));
                    }
                });
                val = val != undef ? val : value;
                if (isObj(val) &amp;&amp; !val.isObservable) val = observable(val);
                target.emit(&#x27;$uberset:&#x27; + key, val);
                return Reflect.set(target, key, val);
            }
        });

        console.warn(&#x27;This JavaScript Environment does not support Proxy, observables need to use the .set and .get accessors to work&#x27;);
        return obj;
    }


    /**
     * Easy way to get a DOM Node or Node within another DOM Node using CSS selectors.
     * @method query
     * @for Craft
     * @param {String} selector - CSS selector to query the DOM Node with
     * @param {Node|String=} element - Optional Node or CSS selector to search within insead of document
     */
    function query(selector, element) {
        if (isStr(element)) element = doc.querySelector(element);
        return is.Node(element) ? element.querySelector(selector) : doc.querySelector(selector);
    }

    /**
     * Easy way to get a DOM NodeList or NodeList within another DOM Node using CSS selectors
     * @method queryAll
     * @for Craft
     * @param {String} selector - CSS selector to query the DOM Nodes with
     * @param {Node|NodeList|String=} element - Optional Node or CSS selector to search within insead of document
     * @return {Array} array containing Nodes and/or Elements
     */
    function queryAll(selector, element) {
        if (isStr(element)) element = queryAll(element);
        let list;
        if (is.Arraylike(element) &amp;&amp; element.length &gt; 1) {
            list = [];
            map(element, el =&gt; {
                if (isStr(el)) el = query(el);
                if (is.Node(el)) {
                    el = queryAll(selector, el);
                    if (is.NodeList(el)) list.concat(el);
                }
            });
        } else {
            list = (is.Node(element) ? element : is.NodeList(element) ? element[0] : doc);
            if (list) {
                list = list.querySelectorAll(selector);
                if (list != null) return slice(list);
            }
        }
        return null;
    }

    /**
     * Easy way to loop through Nodes in the DOM using a CSS Selector or a NodeList
     * @method queryEach
     * @for Craft
     * @param {String|NodeList|Node} selector - CSS selector to query the DOM Nodes with or NodeList to iterate through
     * @param {Node|String} [element] - Optional Node or CSS selector to search within insead of document
     * @param {Function} func - function called on each iteration -&gt; &quot;function( Element , index ) {...}&quot;
     * @param {Boolean} [returnList] - should queryEach also return the list of nodes
     */
    function queryEach(selector, element, func, returnList) {
        if (isFunc(element)) func = element;
        const list = queryAll(selector, element);
        if (list) list.forEach(func);
        if (returnList) return list;
    }

    /**
     * Event Handler
     * @class EventHandler
     * @for Craft
     * @param {String} EventType - set the type of event to listen for example &quot;click&quot; or &quot;scroll&quot;
     * @param {Node|NodeList|window|document} Target - the Event Listener&#x27;s target , can also be a NodeList to listen on multiple Nodes
     * @param {Function} Func - Handler function that will be called when the event is triggered -&gt; &quot;function( event , event.srcElement ) {...}&quot;
     * @return Interface on,off,once
     */
    const EventHandler = (EventType, Target, func, Within) =&gt; new function () {
        const evthandler = this;
        evthandler.state = false;
        Target = (Target !== root &amp;&amp; Target !== doc) &amp;&amp; isStr(Target) ? queryAll(Target, Within) : isArr(Target) ? Craft.flatten(Target) : [Target];
        if (isStr(EventType) &amp;&amp; EventType.includes(&#x27;,&#x27;)) EventType = EventType.split(&#x27;,&#x27;);
        if (!isArr(EventType)) EventType = [EventType];

        let FuncWrapper = e =&gt; func(e, e.target, Target);

        /**
         * Get or Set the Event type to listen for
         * @property Type
         * @type {String}
         * @for EventHandler
         * @return {String} type - the name of the event/s to listen for
         */
        defineprop(evthandler, &#x27;Type&#x27;, {
            set(type) {
                //  have you tried turning it on and off again? - THE IT CROWD
                ehdl.off();
                EventType = type.includes(&#x27;,&#x27;) ? type.split(&#x27;,&#x27;) : type;
                if (!isArr(EventType)) EventType = [EventType];
                ehdl.on();
            },
            get() {
                return EventType;
            },
            enumerable: true
        });
        /**
         * Activates the EventHandler to start listening for the EventType on the Target/Targets
         * @method on
         * @for EventHandler
         * @chainable
         */
        evthandler.on = function () {
            Target.map(target =&gt; {
                EventType.map(evt =&gt; {
                    target.addEventListener(evt, FuncWrapper);
                });
            });
            evthandler.state = true;
            return evthandler;
        };

        /**
         * De-activates / turns off the EventHandler to stop listening for the EventType on the Target/Targets can still optionally be re-activated with on again
         * @method off
         * @for EventHandler
         * @chainable
         */
        evthandler.off = function () {
            Target.map(target =&gt; {
                EventType.map(evt =&gt; {
                    target.removeEventListener(evt, FuncWrapper);
                });
            });
            evthandler.state = false;
            return evthandler;
        };

        /**
         * once the the Event has been triggered the EventHandler will stop listening for the EventType on the Target/Targets the Handler function will be called only once
         * @method once
         * @for EventHandler
         * @chainable
         */
        evthandler.once = () =&gt; {
            FuncWrapper = e =&gt; {
                func(e, e.target, Target);
                evthandler.off();
                evthandler.state = false;
            };
            return evthandler.on();
        };
    };

    function EventTypes(Target, within, listen) {
        const etype = type =&gt; fn =&gt; EventHandler(type, Target, fn, within)[listen || &#x27;on&#x27;]();
        return {
            Click: etype(&#x27;click&#x27;),
            Input: etype(&#x27;input&#x27;),
            DoubleClick: etype(&#x27;dblclick&#x27;),
            Focus: etype(&#x27;focus&#x27;),
            Blur: etype(&#x27;blur&#x27;),
            Keydown: etype(&#x27;keydown&#x27;),
            Mousemove: etype(&#x27;mousemove&#x27;),
            Mousedown: etype(&#x27;mousedown&#x27;),
            Mouseup: etype(&#x27;mouseup&#x27;),
            Mouseover: etype(&#x27;mouseover&#x27;),
            Mouseout: etype(&#x27;mouseout&#x27;),
            Mouseenter: etype(&#x27;mouseenter&#x27;),
            Mouseleave: etype(&#x27;mouseleave&#x27;),
            Scroll: etype(&#x27;scroll&#x27;)
        };
    }

    function keyhandle(keycode) {
        return (fn, context) =&gt; function (evt) {
            if (evt.keyCode === keycode) fn.apply(context || this, arguments);
        };
    }

    function EvtLT(ListenType) {
        return function (EventType, Target, element, func) {
            let args = slice(arguments);
            return isFunc(Target) ? EventHandler(EventType, root, Target)[ListenType]() :
                args.length &lt; 3 &amp;&amp; !args.some(isFunc) ? EventTypes(EventType, Target, ListenType) :
                isFunc(element) ? EventHandler(EventType, Target, element)[ListenType]() :
                EventHandler(EventType, Target, func, element)[ListenType]();
        };
    }

    /**
     * Starts listening for an EventType on the Target/Targets
     * @method on
     * @for Craft
     * @param {String} EventType - set the type of event to listen for example &quot;click&quot; or &quot;scroll&quot;
     * @param {Node|NodeList|window|document} Target - the Event Listener&#x27;s target , can be a NodeList to listen on multiple Nodes
     * @param {Function} Func - Handler function that will be called when the event is triggered -&gt; &quot;function( event , event.srcElement ) {...}&quot;
     * @return off - when on is defined as a variable &quot;var x = on(...)&quot; it allows you to access all the EventHandler interfaces off,once,on
     */
    const on = EvtLT(&#x27;on&#x27;);
    /**
     * Starts listening for an EventType on the Target/Targets ONCE after triggering the once event Listener will stop listening
     * @method once
     * @for Craft
     * @param {String} EventType - set the type of event to listen for example &quot;click&quot; or &quot;scroll&quot;
     * @param {Node|NodeList|window|document} Target - the Event Listener&#x27;s target , can be a NodeList to listen on multiple Nodes
     * @param {Function} Func - Handler function that will be called when the event is triggered -&gt; &quot;function( event , event.srcElement ) {...}&quot;
     * @return on,off,once - when once is defined as a variable &quot;var x = once(...)&quot; it allows you to access all the EventHandler interfaces off,once,on
     */
    const once = EvtLT(&#x27;once&#x27;);

    const eventoptions = &#x27;Click,Input,DoubleClick,Focus,Blur,Keydown,Mousemove,Mousedown,Mouseup,Mouseover,Mouseout&#x27;.split(&#x27;,&#x27;);

    function craftElement(name, inner, attributes, extraAttr, stringForm) {
        let element = domManip(doc.createElement(name));
        if (isObj(inner)) {
            attributes = inner;
            inner = undef;
        }
        if (inner != undef) element.html(inner);
        if (isObj(attributes) || isStr(attributes)) {
            if (isObj(attributes)) Object.keys(attributes).forEach(key =&gt; {
                if (eventoptions.some(is.eq(key)) &amp;&amp; isFunc(attributes[key])) {
                    let func = attributes[key];
                    key == &#x27;DoubleClick&#x27; ? key = &#x27;dblclick&#x27; : key = key.toLowerCase();
                    element[key + &#x27;handle&#x27;] = on(key, element, func);
                    delete attributes[key];
                }
            });
            element.setAttr(attributes);
        }
        if (extraAttr != undef) is.Bool(extraAttr) ? stringForm = extraAttr : element.setAttr(extraAttr);
        if (stringForm) element = element.outerHTML;
        /*
          // start handling directives early on element lifecycle
          if (element.attributes) map(element.attributes, attr =&gt; {
              if (Craft.Directives.has(attr.name)) {
                  manageAttr(element, attr, attr.textContent, &#x27;&#x27;, true);
              }
          });
        */

        return element;
    }

    /**
     * Contains several methods for Element Creation
     * @class dom
     */
    let Dom = {
        /**
         * craft elements on the fly using this nifty method
         * @method element
         * @for dom
         * @param {String} name - tag name of element to be created
         * @param {String|NodeList|Array|Node} inner - inner value(s) of element
         * @param {Object|String} attributes - Key value pair object defining element attributes or URI variable style string
         * @return {Element} newly created element
         */
        element: craftElement,
        /**
         * Makes document fragments also allows attaching nodes or strings that get converted to html.
         * @for dom
         * @method frag
         * @param {String|Node} [inner] - node or string to convert to html
         * @return {DocumentFragment}
         */
        frag(inner) {
            let dfrag;
            if (isStr(inner)) dfrag = dffstr(inner);
            if (!is.Node(dfrag)) dfrag = doc.createDocumentFragment();
            if (is.Node(inner)) dfrag.appendChild(inner);
            return dfrag;
        },
        /**
         * creates an img element with the options provided
         * @method img
         * @for dom
         * @param {String} sets src of the img
         * @param {String} sets alt of the img
         * @param {String|Object} [attr] Key value pair object defining element attributes or URI variable style string
         */
        img: (src, alt, attr) =&gt; Dom.element(&#x27;img&#x27;, &#x27;&#x27;, attr, {
            src: src,
            alt: alt
        }),
        input(type, attr) {
            if (isObj(type)) {
                attributes = type;
                type = &#x27;text&#x27;;
            }
            return Dom.element(&#x27;input&#x27;, &#x27;&#x27;, attr, {
                type: type || &#x27;text&#x27;
            });
        },
        list(type, items, attr) {
            let list = &#x60;&#x60;;
            if (is.Arrylike(items))
                map(items, item =&gt; {
                    if (isStr(item)) list += Dom.element(&#x27;li&#x27;, item).outerHTML;
                    else if (isObj(items)) list += Dom.element(&#x27;li&#x27;, item.inner, item.attr).outerHTML;
                });
            return Dom.element(type, list, attr);
        },
        a: (link, inner, attr) =&gt; Dom.element(&#x27;a&#x27;, inner, attr, &#x27;href=&#x27; + link),
        script(code, attr, defer, onload, nosrc) {
            let script = Dom.element(&#x27;script&#x27;, &#x27;&#x27;, attr, {
                type: &#x27;text/javascript&#x27;
            });
            if (code.slice(0, 4) === &#x27;src=&#x27;) return script.setAttr(code);
            if (isFunc(onload)) {
                script.onload = () =&gt; {
                    script.removeAttribute(&#x27;initx&#x27;);
                    onload();
                };
                let random = Craft.randomInt(1000);
                script.setAttribute(&#x27;initx&#x27;, random);
                code += &#x60;\ndocument.head.querySelector(&#x27;script[initx=&quot;${random}&quot;]&#x27;).dispatchEvent(new UIEvent(&#x27;load&#x27;));\n&#x60;;
            }
            if (defer == true) script.defer = defer != false;
            if (nosrc == true) script.text = code;
            else script.src = Craft.URLfrom(code, {
                type: &#x27;text/javascript&#x27;
            });
            return script;
        }
    };
    &#x27;table,td,th,tr,article,aside,ul,ol,li,h1,h2,h3,h4,h5,h6,div,span,pre,code,section,button,br,label,header,i,style,nav,menu,main,menuitem&#x27;.split(&#x27;,&#x27;).map(tag =&gt; {
        Dom[tag] = (inner, attr, ea) =&gt; Dom.element(tag, inner, attr, ea);
    });

    function domNodeList(elements) {
        if (!isArr(elements)) removeFrom(Object.getOwnPropertyNames(Array.prototype), &#x27;length&#x27;).map(method =&gt; {
            elements[method] = Array.prototype[method];
        });

        /**
         * Listen for Events on the NodeList
         * @method elements.on
         * @for dom
         * @param {String} string indicating the type of event to listen for
         * @param {Function} func - handler function for the event
         * @return handler (off,once,on)
         */
        elements.on = (eventType, func) =&gt; on(eventType, elements, func);
        /**
         * add CSS style rules to NodeList
         * @method elements.css
         * @param {object} styles - should contain all the styles you wish to add example { borderWidth : &#x27;5px solid red&#x27; , float : &#x27;right&#x27;}...
         */
        elements.css = styles =&gt; Craft.css(elements, styles);
        elements.addClass = function (Class) {
            elements.map(el =&gt; {
                el.classList.add(Class);
            });
            return elements;
        };
        elements.gotClass = function () {
            const args = slice(arguments);
            return elements.every(el =&gt; args.every(Class =&gt; el.classList.contains(Class)));
        };

        elements.gotSomeClass = function () {
            const args = slice(arguments);
            return elements.some(el =&gt; args.every(Class =&gt; el.classList.contains(Class)));
        };

        elements.stripClass = Class =&gt; {
            elements.map(el =&gt; {
                el.classList.remove(Class);
            });
            return elements;
        };
        elements.toggleClass = (Class, state) =&gt; {
            elements.map(el =&gt; {
                (is.Bool(state) ? state : el.classList.contains(Class)) ? el.classList.remove(Class): el.classList.add(Class);
            });
            return elements;
        };

        /**
         * removes a specific Attribute from the this.element
         * @method elements.stripAttr
         * @for dom
         * @param {...String} name of the Attribute/s to strip
         */
        elements.stripAttr = function () {
            elements.map(el =&gt; {
                map(arguments, attr =&gt; {
                    el.removeAttribute(attr);
                });
            });
            return elements;
        };
        /**
         * checks if the element has a specific Attribute or Attributes
         * @method hasAttr
         * @for dom
         * @param {String|Boolean} name of the Attribute or if true checks that it has some (||) of the attributes or if false checks that it has all of the attributes (&amp;&amp;)
         * @param {...String} names of attributes to check for
         */
        elements.hasAttr = function (attr) {
            if (isStr(attr) &amp;&amp; arguments.length == 1) return elements.every(el =&gt; el.hasAttribute(attr));
            const args = Craft.flatten(arguments);
            return elements.every(el =&gt; args.every(a =&gt; el.hasAttribute(a)));
        };
        /**
         * Toggles an attribute on element , optionally add value when toggle is adding attribute.
         * @method toggleAttr
         * @for dom
         * @param {String} name - name of the attribute to toggle
         * @param {String} val - value to set attribute to
         * @param {Boolean=} rtst - optionally return a bool witht the toggle state otherwise returns the element
         */
        elements.toggleAttr = function (name, val, rtst) {
            elements.map(el =&gt; {
                el[((is.Bool(val) ? !val : el.hasAttr(name)) ? &#x27;strip&#x27; : &#x27;set&#x27;) + &#x27;Attr&#x27;](name, val);
            });
            return rtst ? elements.every(el =&gt; el.hasAttr(name)) : elements;
        };
        /**
         * Sets or adds an Attribute on elements of a NodeList
         * @method setAttr
         * @for dom
         * @param {String} Name of the Attribute to add/set
         * @param {String} Value of the Attribute to add/set
         */
        elements.setAttr = function (attr, val) {
            elements.map(el =&gt; {
                if (!def(val)) {
                    if (isStr(attr)) attr.includes(&#x27;=&#x27;) || attr.includes(&#x27;&amp;&#x27;) ? attr.split(&#x27;&amp;&#x27;).forEach(Attr =&gt; {
                            let attribs = Attr.split(&#x27;=&#x27;);
                            def(attribs[1]) ? element.setAttribute(attribs[0], attribs[1]) : element.setAttribute(attribs[0], &#x27;&#x27;);
                        }) :
                        element.setAttribute(attr, &#x27;&#x27;);
                    else if (isObj(attr)) forEach(attr, (value, Attr) =&gt; {
                        element.setAttribute(Attr, value);
                    });
                } else element.setAttribute(attr, val || &#x27;&#x27;);
            });
            return elements;
        };

        elements.append = function () {
            map(arguments, arg =&gt; {
                elements.map(el =&gt; {
                    el.appendChild((is.Node(val) ? val : dffstr(val)).cloneNode(true));
                });
            });
            return elements;
        };
        elements.appendTo = (val, within) =&gt; {
            elements.map(el =&gt; {
                if (isStr(el)) el = query(val, within);
                if (is.Node(el)) el.appendChild(el);
            });
            return elements;
        };
        elements.prepend = function () {
            map(arguments, val =&gt; {
                elements.map(el =&gt; {
                    el.insertBefore((is.Node(val) ? val : dffstr(val)).cloneNode(true), el.firstChild);
                });
            });
            return elements;
        };
        elements.hide = () =&gt; elements.css({
            display: &#x27;none&#x27;
        });
        elements.show = () =&gt; elements.css({
            display: &#x27;&#x27;
        });

        elements.pick = i =&gt; {
            if (is.int(i) &amp;&amp; def(elements[i])) return dom(elements[i]);
            else if (elements.includes(i)) return dom(i);
        };
        return elements;
    }

    function Inner(type, el) {
        type = el.isInput ? &#x27;value&#x27; : type;
        return function () {
            if (!arguments.length) return el[type];
            if (el[type].length) el[type] = &#x27;&#x27;;
            Craft.flatten(arguments).map(val =&gt; {
                is.Node(val) ? el.append(val) : el[type] += isFunc(val) ? val.call(el) : val;
            });
            return el;
        };
    }

    function newSetGet(key, set, get) {
        defineprop(this, key, {
            set: set,
            get: get
        });
    }

    function domManip(element, within) {
        if (isStr(element)) element = query(element, within);
        if (element._DOMM == true) return element;
        element._DOMM = true;
        element.isInput = is.Input(element);
        if (!element.state) element.state = eventsys();

        element.newSetGet = newSetGet;

        element.newSetGet(&#x27;colorAccent&#x27;, func =&gt; {
            if (element.hasAttr(&#x27;color-accent&#x27;) &amp;&amp; isFunc(func)) func(element.getAttr(&#x27;color-accent&#x27;));
        });

        /**
         * changes or returns the innerHTML value of a Node
         * @method element.html
         * @for dom
         * @param {String=} sets the innerHTML value or when undefined gets the innerHTML value
         */
        element.html = Inner(&#x27;innerHTML&#x27;, element);

        /**
         * changes or returns the textContent value of a Node
         * @method element.Text
         * @for dom
         * @param {String=} sets the textContent value or when undefined gets the textContent value
         */
        element.Text = Inner(&#x27;textContent&#x27;, element);

        /**
         * element.bind is what drives data-binding in Crafter.js it binds to values in models and objects
         * @method element.bind
         * @for dom
         * @param {String} bind - path to bind to
         * @example element.bind(&#x27;myModel.value&#x27;);
         */
        element.bind = bind =&gt; {
            if (!bind.includes(&#x27;.&#x27;)) {
                if (!def(root[bind])) {
                    let getval = element.html();
                    if (getval) Craft.setDeep(root, bind, getval);
                } else element.html(root[bind]);
                if (element.isInput) element.SyncInput(root, bind, val =&gt; {
                    queryEach(&#x60;[bind=${bind}]&#x60;, el =&gt; {
                        if (val != undef) el.html(val);
                    });
                });
                return element;
            }

            let {
                obj,
                cutbind,
                prop,
                val
            } = Craft.getPath(bind, true);

            function bindval() {
                let alt, path = joindot(Craft.omit(cutbind, cutbind[0]));
                if (!def(val)) val = Craft.getDeep(obj, path);
                def(val) ? element.html(val) : Craft.setDeep(obj, path, element.html());
                if (obj.isObservable) element.state.binder = obj.on(&#x27;$uberset:&#x27; + prop, element.html);
                else alt = val =&gt; {
                    queryEach(&#x60;[bind=${bind}]&#x60;, el =&gt; {
                        if (val != undef) el.html(val);
                    });
                };
                if (element.isInput) element.SyncInput(obj, cutbind.length == 1 ? cutbind[0] : path, alt);
            }

            if (!obj) Craft.modelInit(cutbind[0], scope =&gt; {
                if (scope) {
                    obj = scope;
                    bindval();
                }
            });
            else bindval();
            return element;
        };

        element.unbind = bind =&gt; {
            if (element.state.binder) {
                element.state.binder.off();
                delete element.state.binder;
            }
        };
        /**
         * replaces a Node with another node provided as a parameter/argument
         * @method replace
         * @for dom
         * @param {Node} Node to replace with
         */
        element.replace = val =&gt; {
            element.parentNode.replaceChild(val, element);
            return element;
        };
        /**
         * clones an element it&#x27;s children, optionally
         * @method clone
         * @for dom
         * @param {Boolean} val - defaults to true if set to false children of element won&#x27;t be cloned
         */
        element.clone = val =&gt; domManip(element.cloneNode(val == undef ? true : val));

        /**
         * imports a file and renders it on to the node
         * @method importview
         * @for dom
         * @param {String) src - url to fetch from
         */
        element.importview = (src, fetchoptions) =&gt; {
            let cache = element.hasAttr(&#x27;cache-view&#x27;);
            if (cache) {
                let view = localStorage.getItem(src);
                if (!nil(view)) {
                    element.html(view);
                    return;
                }
            }
            fetch(src, fetchoptions || {
                mode: &#x27;cors&#x27;,
                credentials: &#x27;same-origin&#x27;
            }).then(res =&gt; {
                if (!res.ok) console.warn(&#x60;&lt;${element.localName}&gt; : unable to import view - ${src}&#x60;);
                else res.text().then(view =&gt; {
                    if (cache) localStorage.setItem(src, view);
                    element.html(view);
                });
            });
        };


        element.append = function () {
            const domfrag = dom.frag();
            Craft.flatten(arguments).map(val =&gt; {
                is.Node(val) ? domfrag.appendChild(val) : domfrag.innerHTML += val;
            });
            element.appendChild(domfrag);
            return element;
        };

        const prepend = element.prepend.bind(element);
        element.prepend = function () {
            const domfrag = dom.frag();
            Craft.flatten(arguments).map(val =&gt; {
                //domfrag.appendChild(is.Node(val) ? val : dffstr(val));
                is.Node(val) ? domfrag.appendChild(val) : domfrag.innerHTML += val;
            });
            isFunc(prepend) ? prepend(domfrag) : element.insertBefore(domfrag, element.firstChild);
            return element;
        };

        /**
         * append the Element to another node using either a CSS selector or a Node
         * @method element.appendTo
         * @for dom
         * @param {Node|String} CSS selector or Node to append the this.element to
         * @chainable
         */
        element.appendTo = function (val, within) {
            if (isStr(val)) val = query(val, within);
            if (is.Node(val)) val.appendChild(element);
            return element;
        };
        /**
         * prepend the Element to another node using either a CSS selector or a Node
         * @method element.prependTo
         * @for dom
         * @param {Node|String} CSS selector or Node to append the this.element to
         * @chainable
         */
        element.prependTo = function (val, within) {
            if (isStr(val)) val = query(val, within);
            if (is.Node(val)) val.insertBefore(element, val.firstChild);
            return element;
        };

        /**
         * used to do things with your element without breaking scope
         * @method element.modify
         * @for dom
         * @param {function} func - callback to execute
         * @chainable
         */
        element.modify = func =&gt; {
            func.call(element, element);
            return element;
        };
        /**
         * Listen for Events on the element or on all the elements in the NodeList
         * @method element.on
         * @for dom
         * @param {String} string indicating the type of event to listen for
         * @param {Function} func - handler function for the event
         * @return handler (off,once,on)
         */
        element.on = (eventType, func) =&gt; on(eventType, element, func);

        element.emit = element.state.emit;

        element.newSetGet(&#x27;ondestroy&#x27;, fn =&gt; {
            if (isFunc(fn)) element.state.on(&#x27;destroy&#x27;, fn);
        });

        function evlt(type) {
            return (fn, ltype) =&gt; (ltype ? once : on)(type, element, fn);
        }

        element.Click = evlt(&#x27;click&#x27;);
        element.Input = evlt(&#x27;input&#x27;);
        element.DoubleClick = evlt(&#x27;dblclick&#x27;);
        element.Focus = evlt(&#x27;focus&#x27;);
        element.Blur = evlt(&#x27;blur&#x27;);
        element.Keydown = evlt(&#x27;keydown&#x27;);
        element.Mousemove = evlt(&#x27;mousemove&#x27;);
        element.Mousedown = evlt(&#x27;mousedown&#x27;);
        element.Mouseup = evlt(&#x27;mouseup&#x27;);
        element.Mouseover = evlt(&#x27;mouseover&#x27;);
        element.Mouseout = evlt(&#x27;mouseout&#x27;);
        element.Mouseenter = evlt(&#x27;mouseenter&#x27;);
        element.Mouseleave = evlt(&#x27;mouseleave&#x27;);

        element.onScroll = (func, pd) =&gt; Craft.onScroll(element, func, pd);

        /* let keypress = code =&gt; (fn, type) =&gt; evlt(&#x27;keydown&#x27;)(element, e =&gt; {
            if (e.which == code || e.keyCode == code) fn(e, element)
        }, type);
        element.Enter = keypress(13);
        element.Escape = keypress(27);
        element.Delete = keypress(46);
        element.Space = keypress(32);
        element.UpArrow = keypress(38);
        element.DownArrow = keypress(40);
        element.LeftArrow = keypress(37);
        element.RightArrow = keypress(39);

        */
        /**
         * add CSS style rules to the Element or NodeList
         * @method element.css
         * @for dom
         * @param {object} styles - should contain all the styles you wish to add
         * @example element.css({ borderWidth : &#x27;5px solid red&#x27; , float : &#x27;right&#x27;});
         */
        element.css = (styles, prop) =&gt; Craft.css(element, styles, prop);
        /**
         * check if the element has got a specific CSS class
         * @method element.gotClass
         * @for dom
         * @param {...String} name of the class to check for
         */
        element.gotClass = function () {
            return slice(arguments).every(Class =&gt; element.classList.contains(Class));
        };

        /**
         * Add a CSS class to the element
         * @method element.addClass
         * @for dom
         * @param {String} name of the class to add
         */
        element.addClass = function () {
            map(arguments, Class =&gt; {
                element.classList.add(Class);
            });
            return element;
        };
        /**
         * removes a specific CSS class from the element
         * @method element.stripClass
         * @for dom
         * @param {...String} name of the class to strip
         */
        element.stripClass = function () {
            map(arguments, Class =&gt; {
                element.classList.remove(Class);
            });
            return element;
        };
        /**
         * Toggle a CSS class to the element
         * @method element.toggleClass
         * @for dom
         * @param {String} name of the class to add
         * @param {Boolean=} state - optionally toggle class either on or off with bool
         * @chainable
         */
        element.toggleClass = function (Class, state) {
            if (!is.Bool(state)) state = element.gotClass(Class);
            element[(state ? &#x27;strip&#x27; : &#x27;add&#x27;) + &#x27;Class&#x27;](Class);
            return element;
        };
        /**
         * removes a specific Attribute from the element
         * @method element.stripAttr
         * @for dom
         * @param {...String} name of the Attribute/s to strip
         * @chainable
         */
        element.stripAttr = function () {
            map(arguments, element.removeAttribute.bind(element));
            return element;
        };
        /**
         * checks if the element has a specific Attribute or Attributes
         * @method element.hasAttr
         * @for dom
         * @param {String|Boolean} name of the Attribute or if true checks that it has some (||) of the attributes or if false checks that it has all of the attributes (&amp;&amp;)
         * @param {...String} names of attributes to check for
         */
        element.hasAttr = function () {
            if (isStr(arguments[0])) return element.hasAttribute(arguments[0]);
            return slice(arguments).every(element.hasAttribute);
        };
        /**
         * Sets or adds an Attribute on the element
         * @method element.setAttr
         * @for dom
         * @param {String} Name of the Attribute to add/set
         * @param {String} Value of the Attribute to add/set
         * @chainable
         */
        element.setAttr = (attr, val) =&gt; {
            if (!def(val)) {
                if (isStr(attr)) attr.includes(&#x27;=&#x27;) || attr.includes(&#x27;&amp;&#x27;) ? attr.split(&#x27;&amp;&#x27;).forEach(Attr =&gt; {
                    def(Attr.split(&#x27;=&#x27;)[1]) ? element.setAttribute(Attr.split(&#x27;=&#x27;)[0], Attr.split(&#x27;=&#x27;)[1]) : element.setAttribute(Attr.split(&#x27;=&#x27;)[0], &#x27;&#x27;);
                }) : element.setAttribute(attr, &#x27;&#x27;);
                else if (isObj(attr)) forEach(attr, (value, Attr) =&gt; {
                    element.setAttribute(Attr, value);
                });
            } else element.setAttribute(attr, val || &#x27;&#x27;);
            return element;
        };
        /**
         * Gets the value of an attribute , short alias for element.getAttribute
         * @method element.getAttr
         * @for dom
         * @param {String} attr - name of attribute to get
         */
        element.getAttr = element.getAttribute;
        element.attr = (attr, val) =&gt; isStr(attr) &amp;&amp; !def(val) ? element.getAttr(attr) : element.setAttr(attr, val);

        element.prop = element.hasAttr;
        /**
         * Toggles an attribute on element , optionally add value when toggle is adding attribute
         * @method element.toggleAttr
         * @for dom
         * @param {String} name - name of the attribute to toggle
         * @param {String} val - value to set attribute to
         * @param {Boolean=} rtst - optionally return a bool witht the toggle state otherwise returns the element
         */
        element.toggleAttr = (name, val, rtst) =&gt; {
            element[((is.Bool(val) ? !val : element.hasAttr(name)) ? &#x27;strip&#x27; : &#x27;set&#x27;) + &#x27;Attr&#x27;](name, val);
            return rtst ? element.hasAttr(name) : element;
        };
        if (!element.remove) element.remove = () =&gt; {
            element.parentNode.removeChild(element);
        };

        /**
         * Remove the element after a time in milliseconds
         * @method element.removeAfter
         * @for dom
         * @param {Number=} time - time to wait before self destructing the element
         */
        element.removeAfter = time =&gt; {
            setTimeout(element.remove.bind(element), time || 5000);
            return element;
        };

        /**
         * gets all the sibling elements of the element
         * @property element.Siblings - array of elements
         * @type {Array}
         * @for dom
         */
        defineprop(element, &#x27;Siblings&#x27;, {
            get() {
                return removeFrom(element.parentNode.children, element).filter(isEl);
            }
        });

        /**
         * gets all the element&#x27;s dimentions (width,height,left,top,bottom,right)
         * @method element.getRect
         * @for dom
         * @return {Object}
         */
        element.getRect = element.getBoundingClientRect;
        /**
         * sets or gets the element&#x27;s pixel width
         * @property element.newSetGet
         * @type {String}
         * @for dom
         * @param {String|Number=} pixel value to set
         */
        element.newSetGet(&#x27;Width&#x27;, pixels =&gt; {
            element.style.width = pixels;
        }, () =&gt; element.getRect().with);

        /**
         * sets or gets the element&#x27;s pixel height
         * @property element.Height
         * @type {Number}
         * @for dom
         * @param {String|number=} pixel value to set
         */
        element.newSetGet(&#x27;Height&#x27;, pixels =&gt; {
            element.style.height = pixels;
        }, () =&gt; element.getRect().height);
        /**
         * move the element using either css transforms or plain css possitioning
         * @method element.move
         * @for dom
         * @param {String|Number} x - x-axis position in pixels
         * @param {String|Number} y - y-axis position in pixels
         * @param {Boolean=} transform - should move set the position using css transforms or not
         */
        element.move = function (x, y, transform) {
            if (transform === true) {
                // element.style.willChange = &#x27;transform&#x27;;
                element.style.transform = &#x60;translateX(${x}px) translateY(${y}px)&#x60;;
            } else {
                element.top = y + &#x27;px&#x27;;
                element.left = x + &#x27;px&#x27;;
            }
        };
        /**
         * performs a query inside the element
         * @method element.query
         * @for dom
         * @param {String} CSS selector
         * @return {Node|Null}
         */
        element.query = selector =&gt; query(selector, element);
        /**
         * performs a queryAll inside the element
         * @method element.queryAll
         * @for dom
         * @param {String} CSS selector
         * @return {NodeList|Null}
         */
        element.queryAll = selector =&gt; queryAll(selector, element);

        element.next = (reset, dm) =&gt; {
            let sb = slice(element.parentNode.children),
                nextnode = sb.indexOf(element) + 1;
            if (!sb[nextnode]) return reset ? (dm ? dom(sb[0]) : sb[0]) : null;
            return dm ? dom(sb[nextnode]) : sb[nextnode];
        };
        element.previous = (reset, dm) =&gt; {
            let sb = slice(element.parentNode.children),
                nextnode = sb.indexOf(element) - 1;
            if (!sb[nextnode]) return reset ? (dm ? dom(sb[sb.length - 1]) : sb[sb.length - 1]) : null;
            return dm ? dom(sb[nextnode]) : sb[nextnode];
        };

        if (element.isInput) {
            element.SyncInput = (obj, key, onset) =&gt; Craft.SyncInput(element, obj, key, onset);
            element.disconectInputSync = () =&gt; Craft.disconectInputSync(element);
        }

        element.observe = (func, options, name) =&gt; {
            if (!isStr(name)) name = &#x27;MutObserver&#x27;;
            element[name] = new MutationObserver(muts =&gt; {
                muts.map(mut =&gt; {
                    func(mut, mut.type, mut.target, mut.addedNodes, mut.removedNodes);
                });
            });
            element[name].observe(element, options || {
                attributes: true,
                childList: true,
                subtree: true
            });
            return element;
        };
        element.unobserve = name =&gt; {
            if (!isStr(name)) name = &#x27;MutObserver&#x27;;
            if (def(element[name])) {
                element[name].disconnect();
                delete element[name];
            }
            return element;
        };
        element.observeAttrs = func =&gt; element.state.on(&#x27;attr&#x27;, func.bind(element));

        return element;
    }

    /**
     * returns many useful methods for interacting with and manipulating the DOM or creating elements
     * @method dom
     * @for Craft
     * @param {Node|NodeList|String=} element - optional Node, NodeList or CSS Selector that will be affected by the methods returned
     * @param {Node|String=} within - optional Node, NodeList or CSS Selector to search in for the element similar to query(element,within)
     * @param {Boolean=} one - even if there are more than one elements matching a selector only return the first one
     */
    function dom(element, within, one) {
        if (isStr(element)) {
            element = !one ? queryAll(element, within) : query(element, within);
            if (is.NodeList(element)) {
                if (element.length &gt; 1) return domNodeList(element);
                else if (element.length == 1) element = element[0];
            }
        }
        if (is.Node(element)) return element[&#x27;_DOMM&#x27;] ? element : domManip(element);
        if (is.NodeList(element)) return domNodeList(element);
        return Dom;
    }
    dom = concatObjects(dom, Dom);
    if (root.Proxy) dom = new Proxy(dom, {
        get(obj, key) {
            if (!obj.hasOwnProperty(key)) {
                if (Dom.hasOwnProperty(key)) return Dom[key];
                return (inner, attr, eattr, str) =&gt; Dom.element(key, inner, attr, eattr, str);
            }
            return obj[key];
        }
    });

    /**
     * Craft is Crafter.js&#x27;s Core containing most functionality.
     * @class Craft
     */
    var Craft = {
        /**
         * general Crafter notification event system
         * @type {Object}
         * @property notifier
         * @for Craft
         */
        notifier: eventsys(),
        /**
         * Returns an object or calls a function with all the differences between two arrays
         * @method arrDiff
         * @for Craft
         * @param {Array} arr - array to be compared
         * @param {Array} newArr - second array to be compared
         * @param {Function=} func - optional function that recieves all the info as parameters
         * @return {Object}
         */
        arrDiff(arr, arrb, func) {
            let added = arrb.filter(item =&gt; {
                    if (!arr.includes(item)) return item;
                }),
                same = arr.filter(item =&gt; {
                    if (arrb.includes(item)) return item;
                }),
                diff = Craft.omit(same.concat(added), undef);
            if (isFunc(func) &amp;&amp; !is.empty(diff)) func(arr, arrb, added, same, diff);
            else return {
                added,
                same,
                diff,
                arr,
                arrb
            };
        },
        deglove,
        last,
        first,
        removeFrom,
        cutdot,
        joindot,
        dffstr,
        toArr,
        toInt,
        observable,
        eventsys,
        dom,
        query,
        queryAll,
        queryEach,
        forEach,
        map,
        on,
        once,
        is,
        UnHTML(html) {
            return html
                .replace(/&lt;script[^&gt;]*?&gt;.*?&lt;\/script&gt;/gi, &#x27;&#x27;)
                .replace(/&lt;style[^&gt;]*?&gt;.*?&lt;\/style&gt;/gi, &#x27;&#x27;)
                .replace(/&lt;![\s\S]*?--[ \t\n\r]*&gt;/gi, &#x27;&#x27;);
        },
        /**
         * Compares two arrays and determines if they are the same array
         * @method sameArray
         * @for Craft
         * @param {Array} arr1 - array one
         * @param {Array} arr2 - array two
         */
        sameArray(arr1, arr2) {
            let i = arr1.length;
            if (i !== arr2.length) return false;
            while (i--)
                if (arr1[i] !== arr2[i]) return false;
            return true;
        },
        /**
         * Generates arrays of a set length , with values or values generated from functions
         * @method array
         * @for Craft
         * @param {Number} len - the integer length of the array to be generated
         * @param {...function|*} val - value to set at each index , multiple value params after lenth will generate nested 2d arrays
         * @return {Array}
         */
        array(len) {
            let arr = [],
                val = slice(arguments, 1);
            if (val.length == 1)
                for (; len &gt; 0; len--) arr.push(isFunc(val[0]) ? val[0]() : val[0]);
            else
                for (; len &gt; 0; len--) arr.push(Craft.array(val.length, val));
            return arr;
        },
        /**
         * Gets all the property keys in any object even the hiden ones
         * @method getAllKeys
         * @for Craft
         * @param {*} obj - object to list keys
         * @return {Array} - array containing all the property keys
         */
        getAllKeys(obj) {
            let props = [];
            do {
                props = props.concat(Object.getOwnPropertyNames(obj));
            } while (obj = Object.getPrototypeOf(obj));
            return props;
        },
        /**
         * flattens, sorts and eliminates doubles from arraylike collections
         * @method unique
         * @for Craft
         * @param {Array|Arraylike} arr
         * @return {Array}
         */
        unique: arr =&gt; toArr(newSet()(Craft.flatten(arr))),
        /**
         * Flattens any multidimentional array or arraylike object
         * @method flatten
         * @for Craft
         * @param {Array|Arraylike} arr - multidimentional array(like) object to flatten
         * @return {Array}
         */
        flatten: arr =&gt; Array.prototype.reduce.call(arr, (flat, toFlatten) =&gt; flat.concat(isArr(toFlatten) ? Craft.flatten(toFlatten) : toFlatten), []),
        /**
         * Gets a value from inside an object using a reference string
         * @method getDeep
         * @for Craft
         * @example Craft.getDeep(myObj,&#x27;Company.employees[16].person.name&#x27;) -&gt; Mr Smithers or Craft.getDeep(anObj,&#x27;Colony.Queen.brood&#x27;) -&gt; [...ants]
         * @param {Object} obj - the object to extract values from
         * @param {String} path - string to reference value by simple dot notation or array refference example Craft.getDeep({ a : { b : [1,2,3] }},&quot;a.b[2]&quot;) -&gt; 3
         */
        getDeep(obj, path) {
            try {
                cutdot(path.replace(/\[(\w+)\]/g, &#x27;.$1&#x27;).replace(/^\./, &#x27;&#x27;)).map(step =&gt; {
                    step in obj ? obj = (obj.isObservable ? obj.get(step) : obj[step]) : obj = undef;
                });
                return obj;
            } catch (e) {}
        },
        /**
         * Craft.setDeep  is similar to getDeep it uses a string to reference to a value
         * @method setDeep
         * @for Craft
         * @param {Object} obj - the object to set values on
         * @param {String} path - string to reference value by simple dot notation
         * @param {*} value - value to set
         * @param {Boolean} robj - should the function return the object
         */
        setDeep(obj, path, val, robj) {
            try {
                if (!path.includes(&#x27;.&#x27;)) obj.isObservable ? obj.set(path, val) : obj[path] = val;
                else {
                    path = cutdot(path);
                    for (let i = 0, temp = obj, plen = path.length - 1; i &lt; plen; i++) {
                        if (path[i] in temp) temp = temp[path[i]];
                        else if (i != plen) temp = (temp.isObservable ? temp.set(path[i], {}) : temp[path[i]] = {});
                        else temp.isObservable ? temp.set(path[plen], val) : temp[path[plen]] = val;
                    }
                }
                if (robj) return obj;
            } catch (e) {
                console.warn(&#x60;Craft.setDeep : ran into some trouble setting ${path}&#x60;);
            }
        },
        /**
         * forEachDeep is used to loop through any multi layered object - (flattens and loops through all enumerable properties in a given object)
         * @method forEachDeep
         * @for Craft
         * @param {Object} obj - the object to loop through
         * @param {Function} func - function to handle each iteration
         * @param {String=} path - string to reference value by simple dot notation
         * @example Craft.forEachDeep({ a : 1 , b : { c : 2}}, (value , key , object, currentPath) =&gt; { console.log(key) })
         */
        forEachDeep(object, func, path) {
            path = path || &#x27;&#x27;;
            let currentPath = path,
                nestable, val, key;
            for (key in object) {
                if (object.hasOwnProperty(key)) val = object[key];
                currentPath = path;
                nestable = false;
                isArr(object) ? currentPath += &#x60;[${key}]&#x60; : !currentPath ? currentPath = key : currentPath += &#x27;.&#x27; + key;
                nestable = func(val, key, object, currentPath) == false;
                if (nestable &amp;&amp; (isArr(val) || isObj(val))) Craft.forEachDeep(val, func, currentPath);
            }
        },
        /**
         * Converts any text to an inline URL code (good for images , svg , scripts or css)
         * @method URLfrom
         * @for Craft
         * @param {String} text - content to convert to an inline URL
         * @param {Object} [type] - additional info to create blob url with
         **/
        URLfrom: (text, type) =&gt; URL.createObjectURL(new Blob([text], type)),
        checkStatus(response) {
            if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) return response;
            let error = new Error(response.statusText);
            error.response = response;
            throw error;
        },
        concatObjects,
        completeAssign(host) {
            slice(arguments, 1).map(source =&gt; {
                let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; {
                    descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
                    return descriptors;
                }, {});
                // by default, Object.assign copies enumerable Symbols too
                Object.getOwnPropertySymbols(source).map(sym =&gt; {
                    let descriptor = Object.getOwnPropertyDescriptor(source, sym);
                    if (descriptor.enumerable) descriptors[sym] = descriptor;
                });
                Object.defineProperties(target, descriptors);
            });
            return target;
        },
        isObservable: obj =&gt; obj.isObservable || false,
        /**
         * Simply clones/duplicates any object or array/arraylike object
         * @method clone
         * @for Craft
         * @param {Array|Object} val - array or object to be cloned
         * @return {Array|Object} cloned result
         */
        clone: val =&gt; isObj(val) ? Object.create(val) : Array.from(val),
        /**
         * omits values from any arraylike object or string
         * @method omitFrom
         * @for Craft
         * @param {arraylike|String} Arr - arraylike object from which values will be omitted
         * @param {...*} values - values to omit from the arraylike object
         * @return {Array|String}
         */
        omitFrom(Arr) {
            const args = slice(arguments, 1);
            if (isStr(Arr))
                args.map(a =&gt; {
                    while (Arr.includes(a)) Arr = Arr.replace(a, &#x27;&#x27;);
                });
            else args.map(a =&gt; Arr = removeFrom(Arr, a));
            return Arr;
        },

        has,
        /**
         * Omits values from Objects, Strings and Arraylike objects
         * @method omit
         * @for Craft
         * @param {Object|Array} val - object from which things may be omitted
         * @param {...*} args - things to omit from Object or Array
         * @return {Object|Array}
         */
        omit(val) {
            if (is.Arraylike(val)) val = Craft.omitFrom.apply(this, arguments);
            const args = slice(arguments, 1);
            if (isObj(val) &amp;&amp; !args.includes(val)) forEach(val, (prop, key) =&gt; {
                if (args.some(v =&gt; v == prop || v == key)) delete val[key];
            });
            return val;
        },
        /**
         * checks which browser you&#x27;re running
         * @method isBrowser
         * @for Craft
         * @param {String} browser - string containing a browser name like &#x27;chrome&#x27;,&#x27;firefox&#x27;...
         * @return {Boolean} - returns whether or not this is the browser you checked for
         */
        isBrowser: browser =&gt; Br.toLowerCase().includes(browser.toLowerCase()),
        /**
         * name of browser and version
         * @type {String}
         * @property browser
         * @for Craft
         */
        browser: Br,
        /**
         * Crafter.js&#x27; router system
         * @class router
         * @for Craft
         * @type Object
         * @property router
         */
        router: {
            handle(event, func) {
                const hash = location.hash;
                if (hash === event) func(event, hash);
                return Craft.notifier.on(event, func);
            },
            open(link, newtab) {
                !newtab ? location = link : open(link);
            },
            set title(title) {
                doc.title = title;
            },
            get title() {
                return doc.title;
            }
        },
        /**
         * Create, remove and manage cookies.
         * @class Cookies
         */
        Cookies: {
            get: key =&gt; decodeURIComponent(doc.cookie.replace(new RegExp(&#x27;(?:(?:^|.*;)\\s*&#x27; + encodeURIComponent(key).replace(/[\-\.\+\*]/g, &#x27;\\$&amp;&#x27;) + &#x27;\\s*\\=\\s*([^;]*).*$)|^.*$&#x27;), &#x27;$1&#x27;)) || null,
            set(key, val, expires, path, domain, secure) {
                if (!key || /^(?:expires|max\-age|path|domain|secure)$/i.test(key)) return false;
                let expiry = &#x27;&#x27;;
                if (expires) {
                    if (is.Num(expires)) expiry = expires == Infinity ? &#x27;; expires=Fri, 11 April 9997 23:59:59 UTC&#x27; : &#x27;; max-age=&#x27; + expires;
                    if (isStr(expires)) expiry = &#x27;; expires=&#x27; + expires;
                    if (is.Date(expires)) expiry = &#x27;; expires=&#x27; + expires.toUTCString();
                }
                doc.cookie = encodeURIComponent(key) + &#x27;=&#x27; + encodeURIComponent(val) + expiry + (domain ? &#x27;; domain=&#x27; + domain : &#x27;&#x27;) + (path ? &#x27;; path=&#x27; + path : &#x27;&#x27;) + (secure ? &#x27;; secure&#x27; : &#x27;&#x27;);
                return true;
            },
            has: key =&gt; key != undef &amp;&amp; new RegExp(&#x27;(?:^|;\\s*)&#x27; + encodeURIComponent(key).replace(/[\-\.\+\*]/g, &#x27;\\$&amp;&#x27;) + &#x27;\\s*\\=&#x27;).test(doc.cookie),
            remove(key, path, domain) {
                if (!Craft.Cookies.has(key)) return false;
                doc.cookie = encodeURIComponent(key) + &#x27;=; expires=Thu, 01 Jan 1970 00:00:00 GMT&#x27; + (domain ? &#x27;; domain=&#x27; + domain : &#x27;&#x27;) + (path ? &#x27;; path=&#x27; + path : &#x27;&#x27;);
                return true;
            },
            keys: () =&gt; doc.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, &#x27;&#x27;).split(/\s*(?:\=[^;]*)?;\s*/).map(decodeURIComponent)
        },
        /**
         * Handles WebSockets in a contained manner with send and recieve methods
         * @class Socket
         * @for Craft
         * @constructor
         * @param {String} address - the WebSocket address example &quot;ws://localhost:3000/&quot; but the ws:// or wss:// is optional
         * @param {Array=} protocols - the protocols to pass to the WebSocket Connection
         */
        Socket(address, protocols) {
            if (!is.URL(address)) {
                let match = address.match(/^(\/.*?)?$/);
                if (is.empty(match)) throw new Error(&#x27;invalid url&#x27;);
                address = location.host + match[0];
            }
            if (!address.includes(&#x27;ws://&#x27;) &amp;&amp; !address.includes(&#x27;wss://&#x27;)) address = (location.protocol === &#x27;http:&#x27; ? &#x27;ws://&#x27; : &#x27;wss://&#x27;) + address;
            if (is.URL(address)) {
                const newSock = () =&gt; protocols ? new WebSocket(address, protocols) : new WebSocket(address);

                let Options = {
                    socket: null,
                    open: false,
                    recievers: [],
                    message: &#x27;&#x27;,
                    set send(msg) {
                        if (Options.socket[&#x27;readyState&#x27;] == 1) Options.socket.send(isObj(msg) ? JSON.stringify(msg) : msg);
                        else {
                            let poll = setInterval(() =&gt; {
                                if (Options.socket[&#x27;readyState&#x27;] == 1) {
                                    Options.socket.send(isObj(msg) ? JSON.stringify(msg) : msg);
                                    clearInterval(poll);
                                }
                            }, 10);
                            setTimeout(clearInterval.bind(null, poll), 2000);
                        }
                    },
                    set recieve(func) {
                        if (isFunc(func)) Options.recievers.push(func);
                    },
                    get recieve() {
                        return Options.message;
                    },
                    close() {
                        Options.socket.close();
                    },
                    reopen() {
                        OpenSock(Options.open ? Options.socket : (Options.socket = newSock()));
                    }
                };

                function OpenSock(sock) {
                    sock.onopen = () =&gt; {
                        Options.open = true;
                        sock.onmessage = e =&gt; {
                            Options.message = e.data;
                            Options.recievers.forEach(fn =&gt; {
                                fn(e.data, e);
                            });
                        };
                    };
                    sock.onclose = () =&gt; {
                        Options.open = false;
                    };
                    sock.onerror = e =&gt; {
                        throw e;
                    };
                }
                OpenSock((Options.socket = newSock()));
                return Options;
            }
        },
        keyhandles: {
            base: keyhandle,
            enter: keyhandle(13),
            delete: keyhandle(8),
            escape: keyhandle(27),
            spacebar: keyhandle(32)
        },
        after(n, func, ctx) {
            !isFunc(func) &amp;&amp; isFunc(n) ? func = n : console.error(&#x27;Craft.after: no function&#x27;);
            n = Number.isFinite(n = +n) ? n : 0;
            if (--n &lt; 1) return function () {
                return func.apply(ctx || this, arguments);
            };
        },
        debounce(wait, func, immediate) {
            let timeout;
            return function () {
                const args = arguments,
                    scope = this,
                    later = () =&gt; {
                        timeout = null;
                        if (!immediate) func.apply(scope, args);
                    },
                    callNow = immediate &amp;&amp; !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(scope, args);
            };
        },
        throttle(wait, func, options) {
            let context, args, result,
                timeout = null,
                previous = 0;
            if (!options) options = {};

            function later() {
                previous = !options.leading ? 0 : Date.now();
                timeout = null;
                result = func.apply(context, args);
                if (!timeout) context = args = null;
            }
            return function () {
                let now = Date.now();
                if (is.False(previous, options.leading)) previous = now;
                let remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining &lt;= 0 || remaining &gt; wait) {
                    if (timeout) {
                        clearTimeout(timeout);
                        timeout = null;
                    }
                    previous = now;
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                } else if (!timeout &amp;&amp; options.trailing == true) timeout = setTimeout(later, remaining);
                return result;
            };
        },
        curry,
        memoize(func, resolver) {
            if (!isFunc(func) || (resolver &amp;&amp; !isFunc(resolver))) throw new TypeError(&#x27;no function&#x27;);
            let cache = new WeakMap,
                memoized = function () {
                    let args = arguments,
                        key = resolver ? resolver.apply(this, args) : args[0];
                    if (cache.has(key)) return cache.get(key);
                    let result = func.apply(this, args);
                    memoized.cache = cache.set(key, result);
                    return result;
                };
            return memoized;
        },
        Once(func, context) {
            let result;
            return function () {
                if (isFunc(func)) {
                    result = func.apply(context || this, arguments);
                    func = null;
                }
                return result;
            };
        },
        css(element, styles, prop) {
            if (isObj(styles))
                forEach(styles, (prop, key) =&gt; {
                    if (isEl(element)) element.style[key] = prop;
                    else if (is.NodeList(element)) forEach(element, el =&gt; {
                        el.style[key] = prop;
                    });
                });
            else if (isStr(styles, prop)) element.style[styles] = prop;
            else throw new Error(&#x27;CSS : Styles Object is not an object&#x27;);
            return element;
        },
        fixURL(url) {
            if (!is.URL(url)) {
                let match = url.match(/^(\/.*?)?$/);
                if (is.empty(match)) throw new Error(&#x27;invalid src&#x27;);
                url = location.host + match[0];
            }
            if (!url.includes(&#x27;http://&#x27;) &amp;&amp; !url.includes(&#x27;https://&#x27;)) url = location.protocol + &#x27;//&#x27; + url;
            return url;
        },
        /**
         * takes in any string of valid css code and executes it
         * @method addCSS
         * @for Craft
         * @param {String} css - css code to execute
         */
        addCSS(css, noimport) {
            query(&#x27;style[crafterstyles]&#x27;, head).textContent += noimport ? css : &#x60;@import url(&quot;${Craft.URLfrom(css, {type: &#x27;text/css&#x27;})}&quot;);\n&#x60;;
        },
        /**
         * imports css and executes it
         * @method importCSS
         * @for Craft
         * @param {String} src - source to fetch from
         * @param {Booleans} gofetch - should fetch instead of @import statement
         */
        importCSS(src, gofetch) {
            if (gofetch) fetch(Craft.fixURL(src), {
                mode: &#x27;cors&#x27;
            }).then(res =&gt; {
                if (!res.ok) console.warn(&#x60;loading css failed - ${src}&#x60;);
                else res.text().then(css =&gt; Craft.addCSS(&#x27;\n&#x27; + css, true));
            });
            else Craft.addCSS(&#x60;@import url(&quot;${Craft.fixURL(src)}&quot;);\n&#x60;, true);
        },
        /**
         * imports fonts and loads them
         * @method importFont
         * @for Craft
         * @param {String} name - name of font as used in css
         * @param {String} src - source to fetch from
         */
        importFont(name, src) {
            Craft.addCSS(&#x60;@font-face {font-family:${name};src:url(&quot;${src.slice(0, 2) === &#x27;./&#x27; ? src : Craft.fixURL(src)}&quot;);}&#x60;, true);
        },
        /**
         * takes in a source then attempts to fetch and execute it
         * @method loadScript
         * @for Craft
         * @param {String} src - source to fetch from
         * @param {Boolean} [funcexec] - execute code from inside a new Function() object
         * @param {Object} [fetchAttr] - fetch request options
         */
        loadScript(src, funcexec, fetchattr) {
            let fetchAttr = {
                mode: &#x27;cors&#x27;
            };
            if (isObj(fetchattr)) fetchAttr = concatObjects(fetchAttr, fetchattr);
            return promise((pass, fail) =&gt; {
                fetch(Craft.fixURL(src), fetchAttr).then(res =&gt; {
                    if (!res.ok) console.warn(&#x60;loading script failed - ${src}&#x60;);
                    else res.text().then(code =&gt; {
                        if (funcexec) {
                            try {
                                pass(new Function(code).call(root));
                            } catch (e) {
                                fail(e);
                            }
                        } else
                            head.appendChild(dom.script(code, {}, false, pass, true));
                    });
                });
            });
        },
        /**
         * fetches and executes multiple scripts
         * @method loadScripts
         * @for Craft
         * @param {Array} urls - array of string urls (sources) to fetch from
         * @param {Boolean} [funcexec] - execute code from inside a new Function() object
         * @param {Object} [fetchAttr] - fetch request options
         * @return {Promise}
         */
        loadScripts(urls, funcexec, fetchattr) {
            return promise((pass, fail) =&gt; {
                let len = 0;
                urls.forEach(src =&gt; {
                    Craft.loadScript(src, funcexec, fetchattr).then(() =&gt; {
                        len++;
                        if (len == urls.length) pass();
                    }).catch(fail);
                });
            });
        },
        /**
         * determines if string contains capital letters
         * @method hasCaps
         * @for Craft
         * @param {String} str
         * @return {Boolean}
         */
        hasCaps: str =&gt; slice(str).some(is.Uppercase),
        /**
         * determines if string contains numbers
         * @method hasNums
         * @for Craft
         * @param {String} str
         * @return {Boolean}
         */
        hasNums: str =&gt; /\d/g.test(str),
        len(val) {
            try {
                return isObj(val) ? Object.keys(val).length : is.Map(val) || is.Set(val) ? val.size : val.length;
            } catch (e) {}
            return -1;
        },
        DateIndex(Collection, date) {
            for (let i = 0; i &lt; Collection.length; i++)
                if (+Collection[i] === +date) return i;
            return -1;
        },
        millis: {
            seconds: n =&gt; (n || 1) * 1000,
            minutes: n =&gt; (n || 1) * 60000,
            hours: n =&gt; (n || 1) * 3600000,
            days: n =&gt; (n || 1) * 86400000,
            weeks: n =&gt; (n || 1) * 604800000,
            months: (n, daysInMonth) =&gt; n * Craft.millis.days((daysInMonth || 30)),
            years: n =&gt; n * Craft.millis.year,
            sec: 1000,
            min: 60000,
            hour: 3600000,
            day: 86400000,
            year: 365 * 86400000
        },
        Directives: newMap(),
        Models: observable(),
        /**
         * Tail Call Optimization for recursive functions
         * @method tco
         * @for Craft
         * @param {Function} fn - function that uses recursion inside
         * @return {Function}
         */
        tco(fn) {
            let active, nextArgs;
            return function () {
                let result;
                nextArgs = arguments;
                if (!active) {
                    active = true;
                    while (nextArgs) result = fn.apply(this, [nextArgs, nextArgs = null][0]);
                    active = false;
                }
                return result;
            };
        },
        /**
         * converts Objects or URL variable strings to a FormData object
         * @method toFormData
         * @for Craft
         * @param {object|String} val - values to convert
         */
        toFormData(val) {
            let formData = new FormData();
            if (isStr(val)) val = val.split(&#x27;&amp;&#x27;);
            forEach(val, v =&gt; {
                if (isStr(v)) {
                    v = v.split(&#x27;=&#x27;);
                    if (v.length == 1) v[1] = &#x27;&#x27;;
                    formData.append(v[0], v[1]);
                } else formData.append(key, v);
            });
            return formData;
        },
        /**
         * handles scrolling events
         * @method onScroll
         * @param {Node} element - target of listener
         * @param {Function} func - callback to handle the event
         * @param {Boolean=} preventDefault - event.preventDefault() or not
         */
        onScroll(element, func, preventDefault) {
            return on(&#x27;wheel&#x27;, element, e =&gt; {
                if (preventDefault) e.preventDefault();
                func(e.deltaY &lt; 1, e);
            });
        },
        /**
         * Promise that resolves when the DOM and WebComponents are all finished loading
         * @property WhenReady
         * @type {Promise}
         * @for Craft
         * @return {Promise} - when everything is done loading WhenReady will return a promise
         */
        get WhenReady() {
            return promise((pass, fail) =&gt; {
                if (ready()) return pass();
                let readytimeout = setTimeout(() =&gt; {
                    if (!ready()) fail(&#x27;loading took too long loaded with errors :(&#x27;);
                }, 5500);
                Craft.notifier.once(&#x27;ready&#x27;, () =&gt; {
                    clearTimeout(readytimeout);
                    pass();
                });
            });
        },
        /**
         * Create&#x27;s Crafter.js models
         * @method model
         * @for Craft
         * @param {String} name - give a name to the model
         * @param {Class} modelclass - Class with constructor to instantiate model
         * @return {Object}
         */
        model(name, model) {
            if (isStr(name) &amp;&amp; isObj(model) &amp;&amp; isFunc(model.init) &amp;&amp; !def(Craft.Models[name])) {
                model = observable(model);
                model.init.call(model, model);
                Craft.Models.set(name, model);
                Craft.Models.emit(name, model);
                if (model.load) Craft.WhenReady.then(model.load.bind(model));
                return model;
            }
            throw new Error(&#x27;Crafter : Model already exists&#x27;);
        },
        modelInit(name, func) {
            Craft.Models[name] != undef ? func.call(Craft, Craft.Models[name]) :
                Craft.Models.once(name, scope =&gt; {
                    func.call(Craft, scope);
                });
        },
        M(key, val) {
            let cutkey = cutdot(key),
                IsValDefined = def(val),
                modelname = cutkey[0],
                type = (IsValDefined ? &#x27;set&#x27; : &#x27;get&#x27;) + &#x27;Deep&#x27;;
            if (def(Craft.Models[modelname])) {
                const model = Craft.Models[modelname];
                return cutkey.length == 1 &amp;&amp; !IsValDefined ? model : Craft[type](model, joindot(Craft.omit(cutkey, modelname)), val);
            }
        },
        getPath(path, full) {
            try {
                let cutbind = cutdot(path),
                    prop = last(cutbind),
                    objaccessor = cutbind[0],
                    obj = def(Craft.Models[objaccessor]) ? Craft.Models[objaccessor] : Craft.getDeep(root, joindot(Craft.omit(cutbind, prop))),
                    val = Craft.getDeep(obj, cutbind.length &gt; 1 ? joindot(Craft.omit(cutbind, objaccessor)) : prop);
                if (full) return {
                    cutbind,
                    objaccessor,
                    path,
                    prop,
                    obj,
                    val
                };
                if (def(val)) return val;
                if (objaccessor === prop &amp;&amp; def(obj)) return obj;
            } catch (e) {
                return {};
            }
        },
        /**
         * Defines custom attributes aka directives.
         * @method directive
         * @for Craft
         * @param {String} name - the name of your custom attribute
         * @param {Function} handle - a function to handle how your custom attribute behaves
         * @example Craft.directive(&#x27;turngreen&#x27;, element =&gt; element.css({ background : &#x27;green&#x27;}));
         **/
        directive(name, handle) {
            if (!Craft.Directives.has(name) &amp;&amp; isObj(handle) &amp;&amp; isFunc(handle.bind)) {
                Craft.Directives.set(name, handle);
                Craft.WhenReady.then(() =&gt; {
                    queryEach(&#x60;[${name}]&#x60;, el =&gt; {
                        el = dom(el);
                        if (el.hasAttr(name)) {
                            if (!is.Set(el.state.directives)) el.state.directives = newSet();
                            if (!el.state.directives.has(name)) {
                                el.state.directives.add(name);
                                let directiveChangeDetetor = el.state.on(&#x60;attr:${name}&#x60;, (name, val, oldval, hasAttr) =&gt; {
                                    if (hasAttr || !def(oldval)) {
                                        if (isFunc(handle.update)) handle.update.call(el, el, val, oldval, hasAttr);
                                    } else if (isFunc(handle.unbind)) {
                                        handle.unbind.call(el, el, val, oldval);
                                        directiveChangeDetetor.off();
                                    }
                                });
                                handle.bind.call(el, el, el.getAttr(name));
                            }
                        }
                    });
                });
            }
        },
        /**
         * converts camel case strings to dashed strings usefull for css properties and such
         * @method camelDash
         * @for Craft
         * @example Craft.camelDash(&#x27;MyCamelCaseName&#x27;) // -&gt; my-camel-case-name
         * @param {String) val - string to convert
         */
        camelDash(val) {
            return val.replace(/([a-z])([A-Z])/g, &#x27;$1-$2&#x27;).toLowerCase();
        },
        /**
         * formats a number into a measurement of data size (Bytes,KB,GB,TB...)
         * @method formatBytes
         * @for Craft
         * @param {Nuber} bytes - number to convert
         * @param {Number} [decimals] - limit decimals to number
         * @return {String}
         */
        formatBytes(bytes, decimals) {
            if (bytes == 0) return &#x27;0 Bytes&#x27;;
            let k = 1000,
                i = Math.floor(Math.log(bytes) / Math.log(k));
            return (bytes / Math.pow(k, i)).toPrecision(decimals + 1 || 3) + &#x27; &#x27; + &#x27;Bytes,KB,MB,GB,TB,PB,EB,ZB,YB&#x27;.split(&#x27;,&#x27;)[i];
        },
        randomNum(max, min) {
            min = min || 0;
            max = max || 100;
            return Math.random() * (max - min) + min;
        },
        randomInt(max, min) {
            min = min || 0;
            max = max || 100;
            return Math.floor(Math.random() * (max - min)) + min;
        },
        /**
         * Generates random alphanumeric strings. default length of 6 characters
         * @method randomStr
         * @for Craft
         * @param {int} max - max length of string
         * @param {int} min - min length of string
         * @return {String}
         */
        randomStr(max, min) {
            let text = &#x27;&#x27;;
            min = min || 0;
            max = max || 6;

            for (; min &lt; max; min++) text += possibleText.charAt(Math.floor(Math.random() * possibleText.length));
            return text;
        },
        /**
         * similar to Craft.randomStr in that it generates a unique string , in this case a Unique ID with random alphanumeric strings separated by hyphens
         * @method GenUID
         * @for Craft
         * @example Craft.GenUID(); // -&gt; &quot;0ebf-c7d2-ef81-2667-08ef-4cde&quot;
         * @param {Number=} len - optional length of uid sections
         * @return {String}
         */
        GenUID: len =&gt; Craft.array(len || 6, () =&gt; Craft.randomStr(4)).join(&#x27;-&#x27;),
        /**
         * method for creating custom elements configuring their lifecycle&#x27;s and inheritance
         * the config Object has 7 distinct options ( created , inserted , destroyed , attr, css, set_X and get_X )
         * @method newComponent
         * @for Craft
         * @param {String} tag - a hyphenated custom HTML tagname for the new element -&gt; &quot;custom-element&quot;
         * @param {object} config - Object containing all the element&#x27;s lifecycle methods / extends and attached methods or properties
         */
        newComponent(tag, config) {
            if (!def(config)) throw new Error(&#x60;Crafter : ${tag} - component config undefined&#x60;);
            if (isFunc(config)) {
                const componentclass = Object.create(config.prototype);
                config = {};
                Craft.omit.apply(null, [Craft.getAllKeys(componentclass)].concat(Craft.getAllKeys(Object.prototype))).map(key =&gt; {
                    if (!key.includes(&#x27;__&#x27;)) config[key] = componentclass[key];
                });
            }
            let element = Object.create(HTMLElement.prototype),
                settings = {},
                dm;
            element.createdCallback = function () {
                let el = dom(this),
                    dealtWith = [];
                for (let key in config) {
                    if (!dealtWith.includes(key)) {
                        if (key.includes(&#x27;set_&#x27;)) {
                            let sgKey = key.split(&#x27;_&#x27;)[1];
                            dealtWith.push(key, &#x27;get_&#x27; + sgKey);
                            el.newSetGet(sgKey, config[key], config[&#x27;get_&#x27; + sgKey]);
                        } else if (key.includes(&#x27;get_&#x27;)) {
                            let sgKey = key.split(&#x27;_&#x27;)[1];
                            dealtWith.push(key, &#x27;set_&#x27; + sgKey);
                            el.newSetGet(sgKey, (isFunc(config[&#x27;set_&#x27; + sgKey]) ? config[&#x27;set_&#x27; + sgKey] : noop), config[key]);
                        }
                    }
                }

                if (isFunc(config[&#x27;attr&#x27;])) el.observeAttrs(config[&#x27;attr&#x27;]);
                if (isFunc(config[&#x27;created&#x27;])) return config[&#x27;created&#x27;].call(el);
            };

            for (let key in config) {
                if (key == &#x27;created&#x27; || key == &#x27;attr&#x27; || (key.includes(&#x27;set_&#x27;) || key.includes(&#x27;get_&#x27;))) continue;

                if (isFunc(config[key]) &amp;&amp; key != &#x27;attr&#x27;) dm = function () { // Adds dom methods to element
                    return config[key].apply(dom(this), arguments);
                };
                key == &#x27;inserted&#x27; ? element.attachedCallback = dm :
                    key == &#x27;destroyed&#x27; ? element.detachedCallback = dm :
                    key.toLowerCase() == &#x27;css&#x27; ? Craft.addCSS(config[key]) :
                    isFunc(config[key]) ? element[key] = dm :
                    defineprop(element, key, getpropdescriptor(config, key));
            }

            settings[&#x27;prototype&#x27;] = element;
            doc.registerElement(tag, settings);
        },
        SyncInput(input, obj, key, onset) {
            if (isStr(input)) input = query(input);
            if (is.Input(input)) {
                let oldval = input.value,
                    onsetfn = isFunc(onset);
                input[sI] = on(&#x27;input,blur,keydown&#x27;, input, e =&gt; {
                    setTimeout(() =&gt; {
                        let val = input.value;
                        if (!(Craft.getDeep(obj, key) == &#x27;&#x27; &amp;&amp; val == &#x27;&#x27;) &amp;&amp; val != oldval) {
                            oldval = val;
                            Craft.setDeep(obj, key, input.value);
                            if (onsetfn) onset(input.value);
                        }
                    }, 0);
                });
            }
        },
        disconectInputSync(input) {
            if (isStr(input)) input = query(input);
            if (is.Node(input) &amp;&amp; def(input[sI])) {
                input[sI].off();
                delete input[sI];
            }
        },
        onTabChange(fn) {
            return Craft.notifier.on(&#x27;tabChange&#x27;, fn);
        },
        every(time, fn, context, pauseondefocus) {
            if (isFunc(fn)) {
                let options = {
                    interval: undef,
                    on() {
                        options.interval = setInterval(fn.bind(is.Bool(context) || !def(context) ? options : context), (isFunc(time) ? time() : time));
                        return options;
                    },
                    off() {
                        clearInterval(options.interval);
                        return options;
                    }
                };
                if (pauseondefocus === true || context === true) Craft.onTabChange(state =&gt; {
                    options[state ? &#x27;on&#x27; : &#x27;off&#x27;]();
                });
                return options.on();
            }
        }
    };

    // takes in an affected element and scans it for custom attributes
    // then handles the custom attribute if it was registered with Craft.directive
    function manageAttr(el, name, val, oldval, hasAttr) {
        if (Craft.Directives.has(name)) {
            const handle = Craft.Directives.get(name);
            if (hasAttr &amp;&amp; val != oldval) {
                el = dom(el);
                if (!is.Set(el.state.directives)) el.state.directives = newSet();
                if (!el.state.directives.has(name)) {
                    el.state.directives.add(name);
                    handle.bind.call(el, el, val);
                } else if (handle.update) handle.update.call(el, el, val, hasAttr);
            } else if (!hasAttr &amp;&amp; handle.unbind) handle.unbind.call(el, el, val, oldval);
        }
        if (el.state) {
            el.state.emit(&#x27;attr&#x27;, name, val, oldval, hasAttr);
            el.state.emit(&#x27;attr:&#x27; + name, name, val, oldval, hasAttr);
        }
    }

    new MutationObserver(muts =&gt; {
        muts.map(mut =&gt; {
            map(mut.removedNodes, el =&gt; {
                if (el.state) el.state.emit(&#x27;destroy&#x27;);
            });
            map(mut.addedNodes, el =&gt; {
                if (el.attributes) map(el.attributes, attr =&gt; {
                    if (Craft.Directives.has(attr.name)) manageAttr(el, attr.name, attr.textContent, &#x27;&#x27;, true);
                });
            });
            if (mut.type == &#x27;attributes&#x27; &amp;&amp; isEl(mut.target) &amp;&amp; mut.attributeName != &#x27;style&#x27;)
                manageAttr(mut.target, mut.attributeName, mut.target.getAttribute(mut.attributeName), mut.oldValue, mut.target.hasAttribute(mut.attributeName));
        });
    }).observe(doc, {
        attributes: true,
        childList: true,
        // characterData: true,
        subtree: true
    });


    head.appendChild(dom.style(&#x27;&#x27;, &#x27;crafterstyles&#x27;));
    let TabChange = ta =&gt; () =&gt; {
        Craft.tabActive = ta;
        Craft.notifier.emit(&#x27;tabChange&#x27;, ta);
    }

    on(&#x27;blur&#x27;, TabChange(false));
    on(&#x27;focus&#x27;, TabChange(true));

    Craft.directive(&#x27;link&#x27;, {
        bind(element, link) {
            if (isFunc(element.onlink)) element.state.linkhandle = Craft.router.handle(link, element.onlink.bind(element));

            function makeLinkHandler(fn) {
                if (isFunc(fn)) {
                    if (element.state.linkhandle) element.state.linkhandle.off();
                    return (element.state.linkhandle = Craft.router.handle(link, fn));
                }
            }
            element.newSetGet(&#x27;onlink&#x27;, makeLinkHandler, () =&gt; makeLinkHandler);
        },
        update(element, link, oldlink) {
            if (link != oldlink) {
                if (isObj(element.state.linkhandle)) element.state.linkhandle.off();
                if (isFunc(element.onunlink)) element.onunlink(link);
            }
        },
        unbind(element, link) {
            if (isObj(element.state.linkhandle)) element.state.linkhandle.off();
            if (isFunc(element.onunlink)) element.onunlink(link);
        }
    });

    Craft.directive(&#x27;bind&#x27;, {
        bind(element, bind) {
            element.bind(bind);
        },
        update(element, bind, oldbind) {
            if (bind != oldbind) {
                element.unbind(oldbind);
                element.bind(bind);
            }
        },
        unbind(element, bind) {
            element.unbind(bind);
        }
    });

    Craft.directive(&#x27;bind-for&#x27;, {
        bind(element, bind) {
            let data = Craft.M(bind);
            if (def(data) &amp;&amp; data.forEach) {
                let domfrag = dom.frag();
                element = element.stripAttr(&#x27;bind-for&#x27;);
                data.forEach(item =&gt; {
                    domfrag.appendChild(element.html(item).clone(true));
                });
                element.replace(domfrag);
            } else element.remove();
        }
    });

    Craft.directive(&#x27;import-view&#x27;, {
        bind(element, src) {
            element.importview(src);
        },
        update(element, src) {
            element.importview(src);
        }
    });

    Craft.directive(&#x27;color-accent&#x27;, {
        bind(element, color) {
            if (isFunc(element.colorAccent)) element.colorAccent(color);
        }
    });

    function init() {
        Ready = true;
        Craft.notifier.emit(&#x27;ready&#x27;);
    }

    !ready() ? once(&#x27;DOMContentLoaded&#x27;, doc, init) : init();

    on(&#x27;hashchange&#x27;, () =&gt; {
        const hash = location.hash;
        Craft.notifier.emit(hash, hash);
    });

    on(&#x27;click&#x27;, (e, target) =&gt; {
        if (target.hasAttribute(&#x27;link&#x27;)) {
            (target.hasAttribute(&#x27;newtab&#x27;) ? root.open : Craft.router.open)(target.getAttribute(&#x27;link&#x27;));
        }
    });

    if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) define([&#x27;Craft&#x27;, &#x27;craft&#x27;], Craft);
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    else if (typeof module === &#x27;object&#x27; &amp;&amp; module.exports) module.exports = Craft;
    // Browser globals (root is window)
    else root.Craft = Craft;

    // console.log(performance.now() - perf, &#x27;Crafter.js&#x27;);
})(document, self);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
